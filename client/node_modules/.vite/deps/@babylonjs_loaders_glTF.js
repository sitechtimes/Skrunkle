import {
  AnimationEvent,
  AssetContainer,
  Bone,
  DataReader,
  Deferred,
  DirectionalLight,
  DracoCompression,
  FreeCamera,
  MeshoptCompression,
  MorphTarget,
  MorphTargetManager,
  PBRMaterial,
  PointLight,
  RawCubeTexture,
  Skeleton,
  Sound,
  SphericalHarmonics,
  SphericalPolynomial,
  SpotLight,
  WeightedSound
} from "./chunk-QIXY5JFG.js";
import {
  AbstractMesh,
  Animation,
  AnimationGroup,
  AnimationKeyInterpolation,
  BoundingInfo,
  Buffer,
  Camera,
  Color3,
  Color4,
  Constants,
  DecodeBase64UrlToBinary,
  Effect,
  ErrorCodes,
  Geometry,
  HemisphericLight,
  IsBase64DataUrl,
  Light,
  LoadFileError,
  Logger,
  Material,
  Matrix,
  Mesh,
  MultiMaterial,
  Observable,
  Quaternion,
  RenderTargetTexture,
  RuntimeError,
  Scalar,
  SceneLoader,
  ShaderMaterial,
  StandardMaterial,
  SubMesh,
  Texture,
  TmpVectors,
  Tools,
  TransformNode,
  Vector2,
  Vector3,
  Vector4,
  VertexBuffer,
  VertexData,
  __export
} from "./chunk-H2RNABWV.js";

// node_modules/@babylonjs/loaders/glTF/glTFValidation.js
function validateAsync(data, rootUrl, fileName, getExternalResource) {
  const options = {
    externalResourceFunction: (uri) => getExternalResource(uri).then((value) => new Uint8Array(value))
  };
  if (fileName) {
    options.uri = rootUrl === "file:" ? fileName : rootUrl + fileName;
  }
  return data instanceof ArrayBuffer ? GLTFValidator.validateBytes(new Uint8Array(data), options) : GLTFValidator.validateString(data, options);
}
function workerFunc() {
  const pendingExternalResources = [];
  onmessage = (message) => {
    const data = message.data;
    switch (data.id) {
      case "init": {
        importScripts(data.url);
        break;
      }
      case "validate": {
        validateAsync(data.data, data.rootUrl, data.fileName, (uri) => new Promise((resolve, reject) => {
          const index = pendingExternalResources.length;
          pendingExternalResources.push({ resolve, reject });
          postMessage({ id: "getExternalResource", index, uri });
        })).then((value) => {
          postMessage({ id: "validate.resolve", value });
        }, (reason) => {
          postMessage({ id: "validate.reject", reason });
        });
        break;
      }
      case "getExternalResource.resolve": {
        pendingExternalResources[data.index].resolve(data.value);
        break;
      }
      case "getExternalResource.reject": {
        pendingExternalResources[data.index].reject(data.reason);
        break;
      }
    }
  };
}
var GLTFValidation = class {
  static ValidateAsync(data, rootUrl, fileName, getExternalResource) {
    if (typeof Worker === "function") {
      return new Promise((resolve, reject) => {
        const workerContent = `${validateAsync}(${workerFunc})()`;
        const workerBlobUrl = URL.createObjectURL(new Blob([workerContent], { type: "application/javascript" }));
        const worker = new Worker(workerBlobUrl);
        const onError = (error) => {
          worker.removeEventListener("error", onError);
          worker.removeEventListener("message", onMessage);
          reject(error);
        };
        const onMessage = (message) => {
          const data2 = message.data;
          switch (data2.id) {
            case "getExternalResource": {
              getExternalResource(data2.uri).then((value) => {
                worker.postMessage({ id: "getExternalResource.resolve", index: data2.index, value }, [value]);
              }, (reason) => {
                worker.postMessage({ id: "getExternalResource.reject", index: data2.index, reason });
              });
              break;
            }
            case "validate.resolve": {
              worker.removeEventListener("error", onError);
              worker.removeEventListener("message", onMessage);
              resolve(data2.value);
              worker.terminate();
              break;
            }
            case "validate.reject": {
              worker.removeEventListener("error", onError);
              worker.removeEventListener("message", onMessage);
              reject(data2.reason);
              worker.terminate();
            }
          }
        };
        worker.addEventListener("error", onError);
        worker.addEventListener("message", onMessage);
        worker.postMessage({ id: "init", url: this.Configuration.url });
        worker.postMessage({ id: "validate", data, rootUrl, fileName });
      });
    } else {
      if (!this._LoadScriptPromise) {
        this._LoadScriptPromise = Tools.LoadScriptAsync(this.Configuration.url);
      }
      return this._LoadScriptPromise.then(() => {
        return validateAsync(data, rootUrl, fileName, getExternalResource);
      });
    }
  }
};
GLTFValidation.Configuration = {
  url: "https://preview.babylonjs.com/gltf_validator.js"
};

// node_modules/@babylonjs/loaders/glTF/glTFFileLoader.js
function readAsync(arrayBuffer, byteOffset, byteLength) {
  try {
    return Promise.resolve(new Uint8Array(arrayBuffer, byteOffset, byteLength));
  } catch (e) {
    return Promise.reject(e);
  }
}
var GLTFLoaderCoordinateSystemMode;
(function(GLTFLoaderCoordinateSystemMode2) {
  GLTFLoaderCoordinateSystemMode2[GLTFLoaderCoordinateSystemMode2["AUTO"] = 0] = "AUTO";
  GLTFLoaderCoordinateSystemMode2[GLTFLoaderCoordinateSystemMode2["FORCE_RIGHT_HANDED"] = 1] = "FORCE_RIGHT_HANDED";
})(GLTFLoaderCoordinateSystemMode || (GLTFLoaderCoordinateSystemMode = {}));
var GLTFLoaderAnimationStartMode;
(function(GLTFLoaderAnimationStartMode2) {
  GLTFLoaderAnimationStartMode2[GLTFLoaderAnimationStartMode2["NONE"] = 0] = "NONE";
  GLTFLoaderAnimationStartMode2[GLTFLoaderAnimationStartMode2["FIRST"] = 1] = "FIRST";
  GLTFLoaderAnimationStartMode2[GLTFLoaderAnimationStartMode2["ALL"] = 2] = "ALL";
})(GLTFLoaderAnimationStartMode || (GLTFLoaderAnimationStartMode = {}));
var GLTFLoaderState;
(function(GLTFLoaderState2) {
  GLTFLoaderState2[GLTFLoaderState2["LOADING"] = 0] = "LOADING";
  GLTFLoaderState2[GLTFLoaderState2["READY"] = 1] = "READY";
  GLTFLoaderState2[GLTFLoaderState2["COMPLETE"] = 2] = "COMPLETE";
})(GLTFLoaderState || (GLTFLoaderState = {}));
var GLTFFileLoader = class {
  constructor() {
    this.onParsedObservable = new Observable();
    this.coordinateSystemMode = GLTFLoaderCoordinateSystemMode.AUTO;
    this.animationStartMode = GLTFLoaderAnimationStartMode.FIRST;
    this.compileMaterials = false;
    this.useClipPlane = false;
    this.compileShadowGenerators = false;
    this.transparencyAsCoverage = false;
    this.useRangeRequests = false;
    this.createInstances = true;
    this.alwaysComputeBoundingBox = false;
    this.loadAllMaterials = false;
    this.loadOnlyMaterials = false;
    this.skipMaterials = false;
    this.useSRGBBuffers = true;
    this.targetFps = 60;
    this.alwaysComputeSkeletonRootNode = false;
    this.preprocessUrlAsync = (url) => Promise.resolve(url);
    this.onMeshLoadedObservable = new Observable();
    this.onSkinLoadedObservable = new Observable();
    this.onTextureLoadedObservable = new Observable();
    this.onMaterialLoadedObservable = new Observable();
    this.onCameraLoadedObservable = new Observable();
    this.onCompleteObservable = new Observable();
    this.onErrorObservable = new Observable();
    this.onDisposeObservable = new Observable();
    this.onExtensionLoadedObservable = new Observable();
    this.validate = false;
    this.onValidatedObservable = new Observable();
    this._loader = null;
    this._state = null;
    this._requests = new Array();
    this.name = "gltf";
    this.extensions = {
      ".gltf": { isBinary: false },
      ".glb": { isBinary: true }
    };
    this.onLoaderStateChangedObservable = new Observable();
    this._logIndentLevel = 0;
    this._loggingEnabled = false;
    this._log = this._logDisabled;
    this._capturePerformanceCounters = false;
    this._startPerformanceCounter = this._startPerformanceCounterDisabled;
    this._endPerformanceCounter = this._endPerformanceCounterDisabled;
  }
  set onParsed(callback) {
    if (this._onParsedObserver) {
      this.onParsedObservable.remove(this._onParsedObserver);
    }
    this._onParsedObserver = this.onParsedObservable.add(callback);
  }
  set onMeshLoaded(callback) {
    if (this._onMeshLoadedObserver) {
      this.onMeshLoadedObservable.remove(this._onMeshLoadedObserver);
    }
    this._onMeshLoadedObserver = this.onMeshLoadedObservable.add(callback);
  }
  set onTextureLoaded(callback) {
    if (this._onTextureLoadedObserver) {
      this.onTextureLoadedObservable.remove(this._onTextureLoadedObserver);
    }
    this._onTextureLoadedObserver = this.onTextureLoadedObservable.add(callback);
  }
  set onMaterialLoaded(callback) {
    if (this._onMaterialLoadedObserver) {
      this.onMaterialLoadedObservable.remove(this._onMaterialLoadedObserver);
    }
    this._onMaterialLoadedObserver = this.onMaterialLoadedObservable.add(callback);
  }
  set onCameraLoaded(callback) {
    if (this._onCameraLoadedObserver) {
      this.onCameraLoadedObservable.remove(this._onCameraLoadedObserver);
    }
    this._onCameraLoadedObserver = this.onCameraLoadedObservable.add(callback);
  }
  set onComplete(callback) {
    if (this._onCompleteObserver) {
      this.onCompleteObservable.remove(this._onCompleteObserver);
    }
    this._onCompleteObserver = this.onCompleteObservable.add(callback);
  }
  set onError(callback) {
    if (this._onErrorObserver) {
      this.onErrorObservable.remove(this._onErrorObserver);
    }
    this._onErrorObserver = this.onErrorObservable.add(callback);
  }
  set onDispose(callback) {
    if (this._onDisposeObserver) {
      this.onDisposeObservable.remove(this._onDisposeObserver);
    }
    this._onDisposeObserver = this.onDisposeObservable.add(callback);
  }
  set onExtensionLoaded(callback) {
    if (this._onExtensionLoadedObserver) {
      this.onExtensionLoadedObservable.remove(this._onExtensionLoadedObserver);
    }
    this._onExtensionLoadedObserver = this.onExtensionLoadedObservable.add(callback);
  }
  get loggingEnabled() {
    return this._loggingEnabled;
  }
  set loggingEnabled(value) {
    if (this._loggingEnabled === value) {
      return;
    }
    this._loggingEnabled = value;
    if (this._loggingEnabled) {
      this._log = this._logEnabled;
    } else {
      this._log = this._logDisabled;
    }
  }
  get capturePerformanceCounters() {
    return this._capturePerformanceCounters;
  }
  set capturePerformanceCounters(value) {
    if (this._capturePerformanceCounters === value) {
      return;
    }
    this._capturePerformanceCounters = value;
    if (this._capturePerformanceCounters) {
      this._startPerformanceCounter = this._startPerformanceCounterEnabled;
      this._endPerformanceCounter = this._endPerformanceCounterEnabled;
    } else {
      this._startPerformanceCounter = this._startPerformanceCounterDisabled;
      this._endPerformanceCounter = this._endPerformanceCounterDisabled;
    }
  }
  set onValidated(callback) {
    if (this._onValidatedObserver) {
      this.onValidatedObservable.remove(this._onValidatedObserver);
    }
    this._onValidatedObserver = this.onValidatedObservable.add(callback);
  }
  dispose() {
    if (this._loader) {
      this._loader.dispose();
      this._loader = null;
    }
    for (const request of this._requests) {
      request.abort();
    }
    this._requests.length = 0;
    delete this._progressCallback;
    this.preprocessUrlAsync = (url) => Promise.resolve(url);
    this.onMeshLoadedObservable.clear();
    this.onSkinLoadedObservable.clear();
    this.onTextureLoadedObservable.clear();
    this.onMaterialLoadedObservable.clear();
    this.onCameraLoadedObservable.clear();
    this.onCompleteObservable.clear();
    this.onExtensionLoadedObservable.clear();
    this.onDisposeObservable.notifyObservers(void 0);
    this.onDisposeObservable.clear();
  }
  loadFile(scene, fileOrUrl, onSuccess, onProgress, useArrayBuffer, onError) {
    this._progressCallback = onProgress;
    const rootUrl = fileOrUrl.name ? "file:" : Tools.GetFolderPath(fileOrUrl);
    const fileName = fileOrUrl.name || Tools.GetFilename(fileOrUrl);
    if (useArrayBuffer) {
      if (this.useRangeRequests) {
        if (this.validate) {
          Logger.Warn("glTF validation is not supported when range requests are enabled");
        }
        const fileRequest = {
          abort: () => {
          },
          onCompleteObservable: new Observable()
        };
        const dataBuffer = {
          readAsync: (byteOffset, byteLength) => {
            return new Promise((resolve, reject) => {
              this._loadFile(scene, fileOrUrl, (data) => {
                resolve(new Uint8Array(data));
              }, true, (error) => {
                reject(error);
              }, (webRequest) => {
                webRequest.setRequestHeader("Range", `bytes=${byteOffset}-${byteOffset + byteLength - 1}`);
              });
            });
          },
          byteLength: 0
        };
        this._unpackBinaryAsync(new DataReader(dataBuffer)).then((loaderData) => {
          fileRequest.onCompleteObservable.notifyObservers(fileRequest);
          onSuccess(loaderData);
        }, onError ? (error) => onError(void 0, error) : void 0);
        return fileRequest;
      }
      return this._loadFile(scene, fileOrUrl, (data) => {
        this._validate(scene, data, rootUrl, fileName);
        this._unpackBinaryAsync(new DataReader({
          readAsync: (byteOffset, byteLength) => readAsync(data, byteOffset, byteLength),
          byteLength: data.byteLength
        })).then((loaderData) => {
          onSuccess(loaderData);
        }, onError ? (error) => onError(void 0, error) : void 0);
      }, true, onError);
    }
    return this._loadFile(scene, fileOrUrl, (data) => {
      this._validate(scene, data, rootUrl, fileName);
      onSuccess({ json: this._parseJson(data) });
    }, useArrayBuffer, onError);
  }
  importMeshAsync(meshesNames, scene, data, rootUrl, onProgress, fileName) {
    return Promise.resolve().then(() => {
      this.onParsedObservable.notifyObservers(data);
      this.onParsedObservable.clear();
      this._log(`Loading ${fileName || ""}`);
      this._loader = this._getLoader(data);
      return this._loader.importMeshAsync(meshesNames, scene, null, data, rootUrl, onProgress, fileName);
    });
  }
  loadAsync(scene, data, rootUrl, onProgress, fileName) {
    return Promise.resolve().then(() => {
      this.onParsedObservable.notifyObservers(data);
      this.onParsedObservable.clear();
      this._log(`Loading ${fileName || ""}`);
      this._loader = this._getLoader(data);
      return this._loader.loadAsync(scene, data, rootUrl, onProgress, fileName);
    });
  }
  loadAssetContainerAsync(scene, data, rootUrl, onProgress, fileName) {
    return Promise.resolve().then(() => {
      this.onParsedObservable.notifyObservers(data);
      this.onParsedObservable.clear();
      this._log(`Loading ${fileName || ""}`);
      this._loader = this._getLoader(data);
      const container = new AssetContainer(scene);
      const materials = [];
      this.onMaterialLoadedObservable.add((material) => {
        materials.push(material);
      });
      const textures = [];
      this.onTextureLoadedObservable.add((texture) => {
        textures.push(texture);
      });
      const cameras = [];
      this.onCameraLoadedObservable.add((camera) => {
        cameras.push(camera);
      });
      return this._loader.importMeshAsync(null, scene, container, data, rootUrl, onProgress, fileName).then((result) => {
        Array.prototype.push.apply(container.geometries, result.geometries);
        Array.prototype.push.apply(container.meshes, result.meshes);
        Array.prototype.push.apply(container.particleSystems, result.particleSystems);
        Array.prototype.push.apply(container.skeletons, result.skeletons);
        Array.prototype.push.apply(container.animationGroups, result.animationGroups);
        Array.prototype.push.apply(container.materials, materials);
        Array.prototype.push.apply(container.textures, textures);
        Array.prototype.push.apply(container.lights, result.lights);
        Array.prototype.push.apply(container.transformNodes, result.transformNodes);
        Array.prototype.push.apply(container.cameras, cameras);
        return container;
      });
    });
  }
  canDirectLoad(data) {
    return data.indexOf("asset") !== -1 && data.indexOf("version") !== -1 || data.startsWith("data:base64," + GLTFFileLoader._MagicBase64Encoded) || data.startsWith("data:;base64," + GLTFFileLoader._MagicBase64Encoded) || data.startsWith("data:application/octet-stream;base64," + GLTFFileLoader._MagicBase64Encoded) || data.startsWith("data:model/gltf-binary;base64," + GLTFFileLoader._MagicBase64Encoded);
  }
  directLoad(scene, data) {
    if (data.startsWith("base64," + GLTFFileLoader._MagicBase64Encoded) || data.startsWith(";base64," + GLTFFileLoader._MagicBase64Encoded) || data.startsWith("application/octet-stream;base64," + GLTFFileLoader._MagicBase64Encoded) || data.startsWith("model/gltf-binary;base64," + GLTFFileLoader._MagicBase64Encoded)) {
      const arrayBuffer = DecodeBase64UrlToBinary(data);
      this._validate(scene, arrayBuffer);
      return this._unpackBinaryAsync(new DataReader({
        readAsync: (byteOffset, byteLength) => readAsync(arrayBuffer, byteOffset, byteLength),
        byteLength: arrayBuffer.byteLength
      }));
    }
    this._validate(scene, data);
    return Promise.resolve({ json: this._parseJson(data) });
  }
  createPlugin() {
    return new GLTFFileLoader();
  }
  get loaderState() {
    return this._state;
  }
  whenCompleteAsync() {
    return new Promise((resolve, reject) => {
      this.onCompleteObservable.addOnce(() => {
        resolve();
      });
      this.onErrorObservable.addOnce((reason) => {
        reject(reason);
      });
    });
  }
  _setState(state) {
    if (this._state === state) {
      return;
    }
    this._state = state;
    this.onLoaderStateChangedObservable.notifyObservers(this._state);
    this._log(GLTFLoaderState[this._state]);
  }
  _loadFile(scene, fileOrUrl, onSuccess, useArrayBuffer, onError, onOpened) {
    const request = scene._loadFile(fileOrUrl, onSuccess, (event) => {
      this._onProgress(event, request);
    }, true, useArrayBuffer, onError, onOpened);
    request.onCompleteObservable.add((request2) => {
      this._requests.splice(this._requests.indexOf(request2), 1);
    });
    this._requests.push(request);
    return request;
  }
  _onProgress(event, request) {
    if (!this._progressCallback) {
      return;
    }
    request._lengthComputable = event.lengthComputable;
    request._loaded = event.loaded;
    request._total = event.total;
    let lengthComputable = true;
    let loaded = 0;
    let total = 0;
    for (const request2 of this._requests) {
      if (request2._lengthComputable === void 0 || request2._loaded === void 0 || request2._total === void 0) {
        return;
      }
      lengthComputable = lengthComputable && request2._lengthComputable;
      loaded += request2._loaded;
      total += request2._total;
    }
    this._progressCallback({
      lengthComputable,
      loaded,
      total: lengthComputable ? total : 0
    });
  }
  _validate(scene, data, rootUrl = "", fileName = "") {
    if (!this.validate) {
      return;
    }
    this._startPerformanceCounter("Validate JSON");
    GLTFValidation.ValidateAsync(data, rootUrl, fileName, (uri) => {
      return this.preprocessUrlAsync(rootUrl + uri).then((url) => scene._loadFileAsync(url, void 0, true, true));
    }).then((result) => {
      this._endPerformanceCounter("Validate JSON");
      this.onValidatedObservable.notifyObservers(result);
      this.onValidatedObservable.clear();
    }, (reason) => {
      this._endPerformanceCounter("Validate JSON");
      Tools.Warn(`Failed to validate: ${reason.message}`);
      this.onValidatedObservable.clear();
    });
  }
  _getLoader(loaderData) {
    const asset = loaderData.json.asset || {};
    this._log(`Asset version: ${asset.version}`);
    asset.minVersion && this._log(`Asset minimum version: ${asset.minVersion}`);
    asset.generator && this._log(`Asset generator: ${asset.generator}`);
    const version = GLTFFileLoader._parseVersion(asset.version);
    if (!version) {
      throw new Error("Invalid version: " + asset.version);
    }
    if (asset.minVersion !== void 0) {
      const minVersion = GLTFFileLoader._parseVersion(asset.minVersion);
      if (!minVersion) {
        throw new Error("Invalid minimum version: " + asset.minVersion);
      }
      if (GLTFFileLoader._compareVersion(minVersion, { major: 2, minor: 0 }) > 0) {
        throw new Error("Incompatible minimum version: " + asset.minVersion);
      }
    }
    const createLoaders = {
      1: GLTFFileLoader._CreateGLTF1Loader,
      2: GLTFFileLoader._CreateGLTF2Loader
    };
    const createLoader = createLoaders[version.major];
    if (!createLoader) {
      throw new Error("Unsupported version: " + asset.version);
    }
    return createLoader(this);
  }
  _parseJson(json) {
    this._startPerformanceCounter("Parse JSON");
    this._log(`JSON length: ${json.length}`);
    const parsed = JSON.parse(json);
    this._endPerformanceCounter("Parse JSON");
    return parsed;
  }
  _unpackBinaryAsync(dataReader) {
    this._startPerformanceCounter("Unpack Binary");
    return dataReader.loadAsync(20).then(() => {
      const Binary = {
        Magic: 1179937895
      };
      const magic = dataReader.readUint32();
      if (magic !== Binary.Magic) {
        throw new RuntimeError("Unexpected magic: " + magic, ErrorCodes.GLTFLoaderUnexpectedMagicError);
      }
      const version = dataReader.readUint32();
      if (this.loggingEnabled) {
        this._log(`Binary version: ${version}`);
      }
      const length = dataReader.readUint32();
      if (!this.useRangeRequests && length !== dataReader.buffer.byteLength) {
        Logger.Warn(`Length in header does not match actual data length: ${length} != ${dataReader.buffer.byteLength}`);
      }
      let unpacked;
      switch (version) {
        case 1: {
          unpacked = this._unpackBinaryV1Async(dataReader, length);
          break;
        }
        case 2: {
          unpacked = this._unpackBinaryV2Async(dataReader, length);
          break;
        }
        default: {
          throw new Error("Unsupported version: " + version);
        }
      }
      this._endPerformanceCounter("Unpack Binary");
      return unpacked;
    });
  }
  _unpackBinaryV1Async(dataReader, length) {
    const ContentFormat = {
      JSON: 0
    };
    const contentLength = dataReader.readUint32();
    const contentFormat = dataReader.readUint32();
    if (contentFormat !== ContentFormat.JSON) {
      throw new Error(`Unexpected content format: ${contentFormat}`);
    }
    const bodyLength = length - dataReader.byteOffset;
    const data = { json: this._parseJson(dataReader.readString(contentLength)), bin: null };
    if (bodyLength !== 0) {
      const startByteOffset = dataReader.byteOffset;
      data.bin = {
        readAsync: (byteOffset, byteLength) => dataReader.buffer.readAsync(startByteOffset + byteOffset, byteLength),
        byteLength: bodyLength
      };
    }
    return Promise.resolve(data);
  }
  _unpackBinaryV2Async(dataReader, length) {
    const ChunkFormat = {
      JSON: 1313821514,
      BIN: 5130562
    };
    const chunkLength = dataReader.readUint32();
    const chunkFormat = dataReader.readUint32();
    if (chunkFormat !== ChunkFormat.JSON) {
      throw new Error("First chunk format is not JSON");
    }
    if (dataReader.byteOffset + chunkLength === length) {
      return dataReader.loadAsync(chunkLength).then(() => {
        return { json: this._parseJson(dataReader.readString(chunkLength)), bin: null };
      });
    }
    return dataReader.loadAsync(chunkLength + 8).then(() => {
      const data = { json: this._parseJson(dataReader.readString(chunkLength)), bin: null };
      const readAsync2 = () => {
        const chunkLength2 = dataReader.readUint32();
        const chunkFormat2 = dataReader.readUint32();
        switch (chunkFormat2) {
          case ChunkFormat.JSON: {
            throw new Error("Unexpected JSON chunk");
          }
          case ChunkFormat.BIN: {
            const startByteOffset = dataReader.byteOffset;
            data.bin = {
              readAsync: (byteOffset, byteLength) => dataReader.buffer.readAsync(startByteOffset + byteOffset, byteLength),
              byteLength: chunkLength2
            };
            dataReader.skipBytes(chunkLength2);
            break;
          }
          default: {
            dataReader.skipBytes(chunkLength2);
            break;
          }
        }
        if (dataReader.byteOffset !== length) {
          return dataReader.loadAsync(8).then(readAsync2);
        }
        return Promise.resolve(data);
      };
      return readAsync2();
    });
  }
  static _parseVersion(version) {
    if (version === "1.0" || version === "1.0.1") {
      return {
        major: 1,
        minor: 0
      };
    }
    const match = (version + "").match(/^(\d+)\.(\d+)/);
    if (!match) {
      return null;
    }
    return {
      major: parseInt(match[1]),
      minor: parseInt(match[2])
    };
  }
  static _compareVersion(a, b) {
    if (a.major > b.major) {
      return 1;
    }
    if (a.major < b.major) {
      return -1;
    }
    if (a.minor > b.minor) {
      return 1;
    }
    if (a.minor < b.minor) {
      return -1;
    }
    return 0;
  }
  _logOpen(message) {
    this._log(message);
    this._logIndentLevel++;
  }
  _logClose() {
    --this._logIndentLevel;
  }
  _logEnabled(message) {
    const spaces = GLTFFileLoader._logSpaces.substr(0, this._logIndentLevel * 2);
    Logger.Log(`${spaces}${message}`);
  }
  _logDisabled(message) {
  }
  _startPerformanceCounterEnabled(counterName) {
    Tools.StartPerformanceCounter(counterName);
  }
  _startPerformanceCounterDisabled(counterName) {
  }
  _endPerformanceCounterEnabled(counterName) {
    Tools.EndPerformanceCounter(counterName);
  }
  _endPerformanceCounterDisabled(counterName) {
  }
};
GLTFFileLoader.IncrementalLoading = true;
GLTFFileLoader.HomogeneousCoordinates = false;
GLTFFileLoader._MagicBase64Encoded = "Z2xURg";
GLTFFileLoader._logSpaces = "                                ";
if (SceneLoader) {
  SceneLoader.RegisterPlugin(new GLTFFileLoader());
}

// node_modules/@babylonjs/loaders/glTF/1.0/index.js
var __exports = {};
__export(__exports, {
  EBlendingFunction: () => EBlendingFunction,
  EComponentType: () => EComponentType,
  ECullingType: () => ECullingType,
  EParameterType: () => EParameterType,
  EShaderType: () => EShaderType,
  ETextureFilterType: () => ETextureFilterType,
  ETextureFormat: () => ETextureFormat,
  ETextureWrapMode: () => ETextureWrapMode,
  GLTFBinaryExtension: () => GLTFBinaryExtension,
  GLTFLoader: () => GLTFLoader,
  GLTFLoaderBase: () => GLTFLoaderBase,
  GLTFLoaderExtension: () => GLTFLoaderExtension,
  GLTFMaterialsCommonExtension: () => GLTFMaterialsCommonExtension,
  GLTFUtils: () => GLTFUtils
});

// node_modules/@babylonjs/loaders/glTF/1.0/glTFLoaderInterfaces.js
var EComponentType;
(function(EComponentType2) {
  EComponentType2[EComponentType2["BYTE"] = 5120] = "BYTE";
  EComponentType2[EComponentType2["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
  EComponentType2[EComponentType2["SHORT"] = 5122] = "SHORT";
  EComponentType2[EComponentType2["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
  EComponentType2[EComponentType2["FLOAT"] = 5126] = "FLOAT";
})(EComponentType || (EComponentType = {}));
var EShaderType;
(function(EShaderType2) {
  EShaderType2[EShaderType2["FRAGMENT"] = 35632] = "FRAGMENT";
  EShaderType2[EShaderType2["VERTEX"] = 35633] = "VERTEX";
})(EShaderType || (EShaderType = {}));
var EParameterType;
(function(EParameterType2) {
  EParameterType2[EParameterType2["BYTE"] = 5120] = "BYTE";
  EParameterType2[EParameterType2["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
  EParameterType2[EParameterType2["SHORT"] = 5122] = "SHORT";
  EParameterType2[EParameterType2["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
  EParameterType2[EParameterType2["INT"] = 5124] = "INT";
  EParameterType2[EParameterType2["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
  EParameterType2[EParameterType2["FLOAT"] = 5126] = "FLOAT";
  EParameterType2[EParameterType2["FLOAT_VEC2"] = 35664] = "FLOAT_VEC2";
  EParameterType2[EParameterType2["FLOAT_VEC3"] = 35665] = "FLOAT_VEC3";
  EParameterType2[EParameterType2["FLOAT_VEC4"] = 35666] = "FLOAT_VEC4";
  EParameterType2[EParameterType2["INT_VEC2"] = 35667] = "INT_VEC2";
  EParameterType2[EParameterType2["INT_VEC3"] = 35668] = "INT_VEC3";
  EParameterType2[EParameterType2["INT_VEC4"] = 35669] = "INT_VEC4";
  EParameterType2[EParameterType2["BOOL"] = 35670] = "BOOL";
  EParameterType2[EParameterType2["BOOL_VEC2"] = 35671] = "BOOL_VEC2";
  EParameterType2[EParameterType2["BOOL_VEC3"] = 35672] = "BOOL_VEC3";
  EParameterType2[EParameterType2["BOOL_VEC4"] = 35673] = "BOOL_VEC4";
  EParameterType2[EParameterType2["FLOAT_MAT2"] = 35674] = "FLOAT_MAT2";
  EParameterType2[EParameterType2["FLOAT_MAT3"] = 35675] = "FLOAT_MAT3";
  EParameterType2[EParameterType2["FLOAT_MAT4"] = 35676] = "FLOAT_MAT4";
  EParameterType2[EParameterType2["SAMPLER_2D"] = 35678] = "SAMPLER_2D";
})(EParameterType || (EParameterType = {}));
var ETextureWrapMode;
(function(ETextureWrapMode2) {
  ETextureWrapMode2[ETextureWrapMode2["CLAMP_TO_EDGE"] = 33071] = "CLAMP_TO_EDGE";
  ETextureWrapMode2[ETextureWrapMode2["MIRRORED_REPEAT"] = 33648] = "MIRRORED_REPEAT";
  ETextureWrapMode2[ETextureWrapMode2["REPEAT"] = 10497] = "REPEAT";
})(ETextureWrapMode || (ETextureWrapMode = {}));
var ETextureFilterType;
(function(ETextureFilterType2) {
  ETextureFilterType2[ETextureFilterType2["NEAREST"] = 9728] = "NEAREST";
  ETextureFilterType2[ETextureFilterType2["LINEAR"] = 9728] = "LINEAR";
  ETextureFilterType2[ETextureFilterType2["NEAREST_MIPMAP_NEAREST"] = 9984] = "NEAREST_MIPMAP_NEAREST";
  ETextureFilterType2[ETextureFilterType2["LINEAR_MIPMAP_NEAREST"] = 9985] = "LINEAR_MIPMAP_NEAREST";
  ETextureFilterType2[ETextureFilterType2["NEAREST_MIPMAP_LINEAR"] = 9986] = "NEAREST_MIPMAP_LINEAR";
  ETextureFilterType2[ETextureFilterType2["LINEAR_MIPMAP_LINEAR"] = 9987] = "LINEAR_MIPMAP_LINEAR";
})(ETextureFilterType || (ETextureFilterType = {}));
var ETextureFormat;
(function(ETextureFormat2) {
  ETextureFormat2[ETextureFormat2["ALPHA"] = 6406] = "ALPHA";
  ETextureFormat2[ETextureFormat2["RGB"] = 6407] = "RGB";
  ETextureFormat2[ETextureFormat2["RGBA"] = 6408] = "RGBA";
  ETextureFormat2[ETextureFormat2["LUMINANCE"] = 6409] = "LUMINANCE";
  ETextureFormat2[ETextureFormat2["LUMINANCE_ALPHA"] = 6410] = "LUMINANCE_ALPHA";
})(ETextureFormat || (ETextureFormat = {}));
var ECullingType;
(function(ECullingType2) {
  ECullingType2[ECullingType2["FRONT"] = 1028] = "FRONT";
  ECullingType2[ECullingType2["BACK"] = 1029] = "BACK";
  ECullingType2[ECullingType2["FRONT_AND_BACK"] = 1032] = "FRONT_AND_BACK";
})(ECullingType || (ECullingType = {}));
var EBlendingFunction;
(function(EBlendingFunction2) {
  EBlendingFunction2[EBlendingFunction2["ZERO"] = 0] = "ZERO";
  EBlendingFunction2[EBlendingFunction2["ONE"] = 1] = "ONE";
  EBlendingFunction2[EBlendingFunction2["SRC_COLOR"] = 768] = "SRC_COLOR";
  EBlendingFunction2[EBlendingFunction2["ONE_MINUS_SRC_COLOR"] = 769] = "ONE_MINUS_SRC_COLOR";
  EBlendingFunction2[EBlendingFunction2["DST_COLOR"] = 774] = "DST_COLOR";
  EBlendingFunction2[EBlendingFunction2["ONE_MINUS_DST_COLOR"] = 775] = "ONE_MINUS_DST_COLOR";
  EBlendingFunction2[EBlendingFunction2["SRC_ALPHA"] = 770] = "SRC_ALPHA";
  EBlendingFunction2[EBlendingFunction2["ONE_MINUS_SRC_ALPHA"] = 771] = "ONE_MINUS_SRC_ALPHA";
  EBlendingFunction2[EBlendingFunction2["DST_ALPHA"] = 772] = "DST_ALPHA";
  EBlendingFunction2[EBlendingFunction2["ONE_MINUS_DST_ALPHA"] = 773] = "ONE_MINUS_DST_ALPHA";
  EBlendingFunction2[EBlendingFunction2["CONSTANT_COLOR"] = 32769] = "CONSTANT_COLOR";
  EBlendingFunction2[EBlendingFunction2["ONE_MINUS_CONSTANT_COLOR"] = 32770] = "ONE_MINUS_CONSTANT_COLOR";
  EBlendingFunction2[EBlendingFunction2["CONSTANT_ALPHA"] = 32771] = "CONSTANT_ALPHA";
  EBlendingFunction2[EBlendingFunction2["ONE_MINUS_CONSTANT_ALPHA"] = 32772] = "ONE_MINUS_CONSTANT_ALPHA";
  EBlendingFunction2[EBlendingFunction2["SRC_ALPHA_SATURATE"] = 776] = "SRC_ALPHA_SATURATE";
})(EBlendingFunction || (EBlendingFunction = {}));

// node_modules/@babylonjs/loaders/glTF/1.0/glTFLoaderUtils.js
var GLTFUtils = class {
  static SetMatrix(scene, source, parameter, uniformName, shaderMaterial) {
    let mat = null;
    if (parameter.semantic === "MODEL") {
      mat = source.getWorldMatrix();
    } else if (parameter.semantic === "PROJECTION") {
      mat = scene.getProjectionMatrix();
    } else if (parameter.semantic === "VIEW") {
      mat = scene.getViewMatrix();
    } else if (parameter.semantic === "MODELVIEWINVERSETRANSPOSE") {
      mat = Matrix.Transpose(source.getWorldMatrix().multiply(scene.getViewMatrix()).invert());
    } else if (parameter.semantic === "MODELVIEW") {
      mat = source.getWorldMatrix().multiply(scene.getViewMatrix());
    } else if (parameter.semantic === "MODELVIEWPROJECTION") {
      mat = source.getWorldMatrix().multiply(scene.getTransformMatrix());
    } else if (parameter.semantic === "MODELINVERSE") {
      mat = source.getWorldMatrix().invert();
    } else if (parameter.semantic === "VIEWINVERSE") {
      mat = scene.getViewMatrix().invert();
    } else if (parameter.semantic === "PROJECTIONINVERSE") {
      mat = scene.getProjectionMatrix().invert();
    } else if (parameter.semantic === "MODELVIEWINVERSE") {
      mat = source.getWorldMatrix().multiply(scene.getViewMatrix()).invert();
    } else if (parameter.semantic === "MODELVIEWPROJECTIONINVERSE") {
      mat = source.getWorldMatrix().multiply(scene.getTransformMatrix()).invert();
    } else if (parameter.semantic === "MODELINVERSETRANSPOSE") {
      mat = Matrix.Transpose(source.getWorldMatrix().invert());
    }
    if (mat) {
      switch (parameter.type) {
        case EParameterType.FLOAT_MAT2:
          shaderMaterial.setMatrix2x2(uniformName, Matrix.GetAsMatrix2x2(mat));
          break;
        case EParameterType.FLOAT_MAT3:
          shaderMaterial.setMatrix3x3(uniformName, Matrix.GetAsMatrix3x3(mat));
          break;
        case EParameterType.FLOAT_MAT4:
          shaderMaterial.setMatrix(uniformName, mat);
          break;
        default:
          break;
      }
    }
  }
  static SetUniform(shaderMaterial, uniform, value, type) {
    switch (type) {
      case EParameterType.FLOAT:
        shaderMaterial.setFloat(uniform, value);
        return true;
      case EParameterType.FLOAT_VEC2:
        shaderMaterial.setVector2(uniform, Vector2.FromArray(value));
        return true;
      case EParameterType.FLOAT_VEC3:
        shaderMaterial.setVector3(uniform, Vector3.FromArray(value));
        return true;
      case EParameterType.FLOAT_VEC4:
        shaderMaterial.setVector4(uniform, Vector4.FromArray(value));
        return true;
      default:
        return false;
    }
  }
  static GetWrapMode(mode) {
    switch (mode) {
      case ETextureWrapMode.CLAMP_TO_EDGE:
        return Texture.CLAMP_ADDRESSMODE;
      case ETextureWrapMode.MIRRORED_REPEAT:
        return Texture.MIRROR_ADDRESSMODE;
      case ETextureWrapMode.REPEAT:
        return Texture.WRAP_ADDRESSMODE;
      default:
        return Texture.WRAP_ADDRESSMODE;
    }
  }
  static GetByteStrideFromType(accessor) {
    const type = accessor.type;
    switch (type) {
      case "VEC2":
        return 2;
      case "VEC3":
        return 3;
      case "VEC4":
        return 4;
      case "MAT2":
        return 4;
      case "MAT3":
        return 9;
      case "MAT4":
        return 16;
      default:
        return 1;
    }
  }
  static GetTextureFilterMode(mode) {
    switch (mode) {
      case ETextureFilterType.LINEAR:
      case ETextureFilterType.LINEAR_MIPMAP_NEAREST:
      case ETextureFilterType.LINEAR_MIPMAP_LINEAR:
        return Texture.TRILINEAR_SAMPLINGMODE;
      case ETextureFilterType.NEAREST:
      case ETextureFilterType.NEAREST_MIPMAP_NEAREST:
        return Texture.NEAREST_SAMPLINGMODE;
      default:
        return Texture.BILINEAR_SAMPLINGMODE;
    }
  }
  static GetBufferFromBufferView(gltfRuntime, bufferView, byteOffset, byteLength, componentType) {
    byteOffset = bufferView.byteOffset + byteOffset;
    const loadedBufferView = gltfRuntime.loadedBufferViews[bufferView.buffer];
    if (byteOffset + byteLength > loadedBufferView.byteLength) {
      throw new Error("Buffer access is out of range");
    }
    const buffer = loadedBufferView.buffer;
    byteOffset += loadedBufferView.byteOffset;
    switch (componentType) {
      case EComponentType.BYTE:
        return new Int8Array(buffer, byteOffset, byteLength);
      case EComponentType.UNSIGNED_BYTE:
        return new Uint8Array(buffer, byteOffset, byteLength);
      case EComponentType.SHORT:
        return new Int16Array(buffer, byteOffset, byteLength);
      case EComponentType.UNSIGNED_SHORT:
        return new Uint16Array(buffer, byteOffset, byteLength);
      default:
        return new Float32Array(buffer, byteOffset, byteLength);
    }
  }
  static GetBufferFromAccessor(gltfRuntime, accessor) {
    const bufferView = gltfRuntime.bufferViews[accessor.bufferView];
    const byteLength = accessor.count * GLTFUtils.GetByteStrideFromType(accessor);
    return GLTFUtils.GetBufferFromBufferView(gltfRuntime, bufferView, accessor.byteOffset, byteLength, accessor.componentType);
  }
  static DecodeBufferToText(view) {
    let result = "";
    const length = view.byteLength;
    for (let i = 0; i < length; ++i) {
      result += String.fromCharCode(view[i]);
    }
    return result;
  }
  static GetDefaultMaterial(scene) {
    if (!GLTFUtils._DefaultMaterial) {
      Effect.ShadersStore["GLTFDefaultMaterialVertexShader"] = [
        "precision highp float;",
        "",
        "uniform mat4 worldView;",
        "uniform mat4 projection;",
        "",
        "attribute vec3 position;",
        "",
        "void main(void)",
        "{",
        "    gl_Position = projection * worldView * vec4(position, 1.0);",
        "}"
      ].join("\n");
      Effect.ShadersStore["GLTFDefaultMaterialPixelShader"] = [
        "precision highp float;",
        "",
        "uniform vec4 u_emission;",
        "",
        "void main(void)",
        "{",
        "    gl_FragColor = u_emission;",
        "}"
      ].join("\n");
      const shaderPath = {
        vertex: "GLTFDefaultMaterial",
        fragment: "GLTFDefaultMaterial"
      };
      const options = {
        attributes: ["position"],
        uniforms: ["worldView", "projection", "u_emission"],
        samplers: new Array(),
        needAlphaBlending: false
      };
      GLTFUtils._DefaultMaterial = new ShaderMaterial("GLTFDefaultMaterial", scene, shaderPath, options);
      GLTFUtils._DefaultMaterial.setColor4("u_emission", new Color4(0.5, 0.5, 0.5, 1));
    }
    return GLTFUtils._DefaultMaterial;
  }
};
GLTFUtils._DefaultMaterial = null;

// node_modules/@babylonjs/loaders/glTF/1.0/glTFLoader.js
var ETokenType;
(function(ETokenType2) {
  ETokenType2[ETokenType2["IDENTIFIER"] = 1] = "IDENTIFIER";
  ETokenType2[ETokenType2["UNKNOWN"] = 2] = "UNKNOWN";
  ETokenType2[ETokenType2["END_OF_INPUT"] = 3] = "END_OF_INPUT";
})(ETokenType || (ETokenType = {}));
var Tokenizer = class {
  constructor(toParse) {
    this._pos = 0;
    this.currentToken = ETokenType.UNKNOWN;
    this.currentIdentifier = "";
    this.currentString = "";
    this.isLetterOrDigitPattern = /^[a-zA-Z0-9]+$/;
    this._toParse = toParse;
    this._maxPos = toParse.length;
  }
  getNextToken() {
    if (this.isEnd()) {
      return ETokenType.END_OF_INPUT;
    }
    this.currentString = this.read();
    this.currentToken = ETokenType.UNKNOWN;
    if (this.currentString === "_" || this.isLetterOrDigitPattern.test(this.currentString)) {
      this.currentToken = ETokenType.IDENTIFIER;
      this.currentIdentifier = this.currentString;
      while (!this.isEnd() && (this.isLetterOrDigitPattern.test(this.currentString = this.peek()) || this.currentString === "_")) {
        this.currentIdentifier += this.currentString;
        this.forward();
      }
    }
    return this.currentToken;
  }
  peek() {
    return this._toParse[this._pos];
  }
  read() {
    return this._toParse[this._pos++];
  }
  forward() {
    this._pos++;
  }
  isEnd() {
    return this._pos >= this._maxPos;
  }
};
var glTFTransforms = ["MODEL", "VIEW", "PROJECTION", "MODELVIEW", "MODELVIEWPROJECTION", "JOINTMATRIX"];
var babylonTransforms = ["world", "view", "projection", "worldView", "worldViewProjection", "mBones"];
var glTFAnimationPaths = ["translation", "rotation", "scale"];
var babylonAnimationPaths = ["position", "rotationQuaternion", "scaling"];
var parseBuffers = (parsedBuffers, gltfRuntime) => {
  for (const buf in parsedBuffers) {
    const parsedBuffer = parsedBuffers[buf];
    gltfRuntime.buffers[buf] = parsedBuffer;
    gltfRuntime.buffersCount++;
  }
};
var parseShaders = (parsedShaders, gltfRuntime) => {
  for (const sha in parsedShaders) {
    const parsedShader = parsedShaders[sha];
    gltfRuntime.shaders[sha] = parsedShader;
    gltfRuntime.shaderscount++;
  }
};
var parseObject = (parsedObjects, runtimeProperty, gltfRuntime) => {
  for (const object in parsedObjects) {
    const parsedObject = parsedObjects[object];
    gltfRuntime[runtimeProperty][object] = parsedObject;
  }
};
var normalizeUVs = (buffer) => {
  if (!buffer) {
    return;
  }
  for (let i = 0; i < buffer.length / 2; i++) {
    buffer[i * 2 + 1] = 1 - buffer[i * 2 + 1];
  }
};
var getAttribute = (attributeParameter) => {
  if (attributeParameter.semantic === "NORMAL") {
    return "normal";
  } else if (attributeParameter.semantic === "POSITION") {
    return "position";
  } else if (attributeParameter.semantic === "JOINT") {
    return "matricesIndices";
  } else if (attributeParameter.semantic === "WEIGHT") {
    return "matricesWeights";
  } else if (attributeParameter.semantic === "COLOR") {
    return "color";
  } else if (attributeParameter.semantic && attributeParameter.semantic.indexOf("TEXCOORD_") !== -1) {
    const channel = Number(attributeParameter.semantic.split("_")[1]);
    return "uv" + (channel === 0 ? "" : channel + 1);
  }
  return null;
};
var loadAnimations = (gltfRuntime) => {
  for (const anim in gltfRuntime.animations) {
    const animation = gltfRuntime.animations[anim];
    if (!animation.channels || !animation.samplers) {
      continue;
    }
    let lastAnimation = null;
    for (let i = 0; i < animation.channels.length; i++) {
      const channel = animation.channels[i];
      const sampler = animation.samplers[channel.sampler];
      if (!sampler) {
        continue;
      }
      let inputData = null;
      let outputData = null;
      if (animation.parameters) {
        inputData = animation.parameters[sampler.input];
        outputData = animation.parameters[sampler.output];
      } else {
        inputData = sampler.input;
        outputData = sampler.output;
      }
      const bufferInput = GLTFUtils.GetBufferFromAccessor(gltfRuntime, gltfRuntime.accessors[inputData]);
      const bufferOutput = GLTFUtils.GetBufferFromAccessor(gltfRuntime, gltfRuntime.accessors[outputData]);
      const targetId = channel.target.id;
      let targetNode = gltfRuntime.scene.getNodeById(targetId);
      if (targetNode === null) {
        targetNode = gltfRuntime.scene.getNodeByName(targetId);
      }
      if (targetNode === null) {
        Tools.Warn("Creating animation named " + anim + ". But cannot find node named " + targetId + " to attach to");
        continue;
      }
      const isBone = targetNode instanceof Bone;
      let targetPath = channel.target.path;
      const targetPathIndex = glTFAnimationPaths.indexOf(targetPath);
      if (targetPathIndex !== -1) {
        targetPath = babylonAnimationPaths[targetPathIndex];
      }
      let animationType = Animation.ANIMATIONTYPE_MATRIX;
      if (!isBone) {
        if (targetPath === "rotationQuaternion") {
          animationType = Animation.ANIMATIONTYPE_QUATERNION;
          targetNode.rotationQuaternion = new Quaternion();
        } else {
          animationType = Animation.ANIMATIONTYPE_VECTOR3;
        }
      }
      let babylonAnimation = null;
      const keys = [];
      let arrayOffset = 0;
      let modifyKey = false;
      if (isBone && lastAnimation && lastAnimation.getKeys().length === bufferInput.length) {
        babylonAnimation = lastAnimation;
        modifyKey = true;
      }
      if (!modifyKey) {
        gltfRuntime.scene._blockEntityCollection = !!gltfRuntime.assetContainer;
        babylonAnimation = new Animation(anim, isBone ? "_matrix" : targetPath, 1, animationType, Animation.ANIMATIONLOOPMODE_CYCLE);
        gltfRuntime.scene._blockEntityCollection = false;
      }
      for (let j = 0; j < bufferInput.length; j++) {
        let value = null;
        if (targetPath === "rotationQuaternion") {
          value = Quaternion.FromArray([bufferOutput[arrayOffset], bufferOutput[arrayOffset + 1], bufferOutput[arrayOffset + 2], bufferOutput[arrayOffset + 3]]);
          arrayOffset += 4;
        } else {
          value = Vector3.FromArray([bufferOutput[arrayOffset], bufferOutput[arrayOffset + 1], bufferOutput[arrayOffset + 2]]);
          arrayOffset += 3;
        }
        if (isBone) {
          const bone = targetNode;
          let translation = Vector3.Zero();
          let rotationQuaternion = new Quaternion();
          let scaling = Vector3.Zero();
          let mat = bone.getBaseMatrix();
          if (modifyKey && lastAnimation) {
            mat = lastAnimation.getKeys()[j].value;
          }
          mat.decompose(scaling, rotationQuaternion, translation);
          if (targetPath === "position") {
            translation = value;
          } else if (targetPath === "rotationQuaternion") {
            rotationQuaternion = value;
          } else {
            scaling = value;
          }
          value = Matrix.Compose(scaling, rotationQuaternion, translation);
        }
        if (!modifyKey) {
          keys.push({
            frame: bufferInput[j],
            value
          });
        } else if (lastAnimation) {
          lastAnimation.getKeys()[j].value = value;
        }
      }
      if (!modifyKey && babylonAnimation) {
        babylonAnimation.setKeys(keys);
        targetNode.animations.push(babylonAnimation);
      }
      lastAnimation = babylonAnimation;
      gltfRuntime.scene.stopAnimation(targetNode);
      gltfRuntime.scene.beginAnimation(targetNode, 0, bufferInput[bufferInput.length - 1], true, 1);
    }
  }
};
var configureBoneTransformation = (node) => {
  let mat = null;
  if (node.translation || node.rotation || node.scale) {
    const scale = Vector3.FromArray(node.scale || [1, 1, 1]);
    const rotation = Quaternion.FromArray(node.rotation || [0, 0, 0, 1]);
    const position = Vector3.FromArray(node.translation || [0, 0, 0]);
    mat = Matrix.Compose(scale, rotation, position);
  } else {
    mat = Matrix.FromArray(node.matrix);
  }
  return mat;
};
var getParentBone = (gltfRuntime, skins, jointName, newSkeleton) => {
  for (let i = 0; i < newSkeleton.bones.length; i++) {
    if (newSkeleton.bones[i].name === jointName) {
      return newSkeleton.bones[i];
    }
  }
  const nodes = gltfRuntime.nodes;
  for (const nde in nodes) {
    const node = nodes[nde];
    if (!node.jointName) {
      continue;
    }
    const children = node.children;
    for (let i = 0; i < children.length; i++) {
      const child = gltfRuntime.nodes[children[i]];
      if (!child.jointName) {
        continue;
      }
      if (child.jointName === jointName) {
        const mat = configureBoneTransformation(node);
        const bone = new Bone(node.name || "", newSkeleton, getParentBone(gltfRuntime, skins, node.jointName, newSkeleton), mat);
        bone.id = nde;
        return bone;
      }
    }
  }
  return null;
};
var getNodeToRoot = (nodesToRoot, id) => {
  for (let i = 0; i < nodesToRoot.length; i++) {
    const nodeToRoot = nodesToRoot[i];
    for (let j = 0; j < nodeToRoot.node.children.length; j++) {
      const child = nodeToRoot.node.children[j];
      if (child === id) {
        return nodeToRoot.bone;
      }
    }
  }
  return null;
};
var getJointNode = (gltfRuntime, jointName) => {
  const nodes = gltfRuntime.nodes;
  let node = nodes[jointName];
  if (node) {
    return {
      node,
      id: jointName
    };
  }
  for (const nde in nodes) {
    node = nodes[nde];
    if (node.jointName === jointName) {
      return {
        node,
        id: nde
      };
    }
  }
  return null;
};
var nodeIsInJoints = (skins, id) => {
  for (let i = 0; i < skins.jointNames.length; i++) {
    if (skins.jointNames[i] === id) {
      return true;
    }
  }
  return false;
};
var getNodesToRoot = (gltfRuntime, newSkeleton, skins, nodesToRoot) => {
  for (const nde in gltfRuntime.nodes) {
    const node = gltfRuntime.nodes[nde];
    const id = nde;
    if (!node.jointName || nodeIsInJoints(skins, node.jointName)) {
      continue;
    }
    const mat = configureBoneTransformation(node);
    const bone = new Bone(node.name || "", newSkeleton, null, mat);
    bone.id = id;
    nodesToRoot.push({ bone, node, id });
  }
  for (let i = 0; i < nodesToRoot.length; i++) {
    const nodeToRoot = nodesToRoot[i];
    const children = nodeToRoot.node.children;
    for (let j = 0; j < children.length; j++) {
      let child = null;
      for (let k = 0; k < nodesToRoot.length; k++) {
        if (nodesToRoot[k].id === children[j]) {
          child = nodesToRoot[k];
          break;
        }
      }
      if (child) {
        child.bone._parent = nodeToRoot.bone;
        nodeToRoot.bone.children.push(child.bone);
      }
    }
  }
};
var importSkeleton = (gltfRuntime, skins, mesh, newSkeleton) => {
  if (!newSkeleton) {
    newSkeleton = new Skeleton(skins.name || "", "", gltfRuntime.scene);
  }
  if (!skins.babylonSkeleton) {
    return newSkeleton;
  }
  const nodesToRoot = [];
  const nodesToRootToAdd = [];
  getNodesToRoot(gltfRuntime, newSkeleton, skins, nodesToRoot);
  newSkeleton.bones = [];
  for (let i = 0; i < skins.jointNames.length; i++) {
    const jointNode = getJointNode(gltfRuntime, skins.jointNames[i]);
    if (!jointNode) {
      continue;
    }
    const node = jointNode.node;
    if (!node) {
      Tools.Warn("Joint named " + skins.jointNames[i] + " does not exist");
      continue;
    }
    const id = jointNode.id;
    const existingBone = gltfRuntime.scene.getBoneById(id);
    if (existingBone) {
      newSkeleton.bones.push(existingBone);
      continue;
    }
    let foundBone = false;
    let parentBone = null;
    for (let j = 0; j < i; j++) {
      const jointNode2 = getJointNode(gltfRuntime, skins.jointNames[j]);
      if (!jointNode2) {
        continue;
      }
      const joint = jointNode2.node;
      if (!joint) {
        Tools.Warn("Joint named " + skins.jointNames[j] + " does not exist when looking for parent");
        continue;
      }
      const children = joint.children;
      if (!children) {
        continue;
      }
      foundBone = false;
      for (let k = 0; k < children.length; k++) {
        if (children[k] === id) {
          parentBone = getParentBone(gltfRuntime, skins, skins.jointNames[j], newSkeleton);
          foundBone = true;
          break;
        }
      }
      if (foundBone) {
        break;
      }
    }
    const mat = configureBoneTransformation(node);
    if (!parentBone && nodesToRoot.length > 0) {
      parentBone = getNodeToRoot(nodesToRoot, id);
      if (parentBone) {
        if (nodesToRootToAdd.indexOf(parentBone) === -1) {
          nodesToRootToAdd.push(parentBone);
        }
      }
    }
    const bone = new Bone(node.jointName || "", newSkeleton, parentBone, mat);
    bone.id = id;
  }
  const bones = newSkeleton.bones;
  newSkeleton.bones = [];
  for (let i = 0; i < skins.jointNames.length; i++) {
    const jointNode = getJointNode(gltfRuntime, skins.jointNames[i]);
    if (!jointNode) {
      continue;
    }
    for (let j = 0; j < bones.length; j++) {
      if (bones[j].id === jointNode.id) {
        newSkeleton.bones.push(bones[j]);
        break;
      }
    }
  }
  newSkeleton.prepare();
  for (let i = 0; i < nodesToRootToAdd.length; i++) {
    newSkeleton.bones.push(nodesToRootToAdd[i]);
  }
  return newSkeleton;
};
var importMesh = (gltfRuntime, node, meshes, id, newMesh) => {
  if (!newMesh) {
    gltfRuntime.scene._blockEntityCollection = !!gltfRuntime.assetContainer;
    newMesh = new Mesh(node.name || "", gltfRuntime.scene);
    newMesh._parentContainer = gltfRuntime.assetContainer;
    gltfRuntime.scene._blockEntityCollection = false;
    newMesh.id = id;
  }
  if (!node.babylonNode) {
    return newMesh;
  }
  const subMaterials = [];
  let vertexData = null;
  const verticesStarts = new Array();
  const verticesCounts = new Array();
  const indexStarts = new Array();
  const indexCounts = new Array();
  for (let meshIndex = 0; meshIndex < meshes.length; meshIndex++) {
    const meshId = meshes[meshIndex];
    const mesh = gltfRuntime.meshes[meshId];
    if (!mesh) {
      continue;
    }
    for (let i = 0; i < mesh.primitives.length; i++) {
      const tempVertexData = new VertexData();
      const primitive = mesh.primitives[i];
      if (primitive.mode !== 4) {
      }
      const attributes = primitive.attributes;
      let accessor = null;
      let buffer = null;
      for (const semantic in attributes) {
        accessor = gltfRuntime.accessors[attributes[semantic]];
        buffer = GLTFUtils.GetBufferFromAccessor(gltfRuntime, accessor);
        if (semantic === "NORMAL") {
          tempVertexData.normals = new Float32Array(buffer.length);
          tempVertexData.normals.set(buffer);
        } else if (semantic === "POSITION") {
          if (GLTFFileLoader.HomogeneousCoordinates) {
            tempVertexData.positions = new Float32Array(buffer.length - buffer.length / 4);
            for (let j = 0; j < buffer.length; j += 4) {
              tempVertexData.positions[j] = buffer[j];
              tempVertexData.positions[j + 1] = buffer[j + 1];
              tempVertexData.positions[j + 2] = buffer[j + 2];
            }
          } else {
            tempVertexData.positions = new Float32Array(buffer.length);
            tempVertexData.positions.set(buffer);
          }
          verticesCounts.push(tempVertexData.positions.length);
        } else if (semantic.indexOf("TEXCOORD_") !== -1) {
          const channel = Number(semantic.split("_")[1]);
          const uvKind = VertexBuffer.UVKind + (channel === 0 ? "" : channel + 1);
          const uvs = new Float32Array(buffer.length);
          uvs.set(buffer);
          normalizeUVs(uvs);
          tempVertexData.set(uvs, uvKind);
        } else if (semantic === "JOINT") {
          tempVertexData.matricesIndices = new Float32Array(buffer.length);
          tempVertexData.matricesIndices.set(buffer);
        } else if (semantic === "WEIGHT") {
          tempVertexData.matricesWeights = new Float32Array(buffer.length);
          tempVertexData.matricesWeights.set(buffer);
        } else if (semantic === "COLOR") {
          tempVertexData.colors = new Float32Array(buffer.length);
          tempVertexData.colors.set(buffer);
        }
      }
      accessor = gltfRuntime.accessors[primitive.indices];
      if (accessor) {
        buffer = GLTFUtils.GetBufferFromAccessor(gltfRuntime, accessor);
        tempVertexData.indices = new Int32Array(buffer.length);
        tempVertexData.indices.set(buffer);
        indexCounts.push(tempVertexData.indices.length);
      } else {
        const indices = [];
        for (let j = 0; j < tempVertexData.positions.length / 3; j++) {
          indices.push(j);
        }
        tempVertexData.indices = new Int32Array(indices);
        indexCounts.push(tempVertexData.indices.length);
      }
      if (!vertexData) {
        vertexData = tempVertexData;
      } else {
        vertexData.merge(tempVertexData);
      }
      const material2 = gltfRuntime.scene.getMaterialById(primitive.material);
      subMaterials.push(material2 === null ? GLTFUtils.GetDefaultMaterial(gltfRuntime.scene) : material2);
      verticesStarts.push(verticesStarts.length === 0 ? 0 : verticesStarts[verticesStarts.length - 1] + verticesCounts[verticesCounts.length - 2]);
      indexStarts.push(indexStarts.length === 0 ? 0 : indexStarts[indexStarts.length - 1] + indexCounts[indexCounts.length - 2]);
    }
  }
  let material;
  gltfRuntime.scene._blockEntityCollection = !!gltfRuntime.assetContainer;
  if (subMaterials.length > 1) {
    material = new MultiMaterial("multimat" + id, gltfRuntime.scene);
    material.subMaterials = subMaterials;
  } else {
    material = new StandardMaterial("multimat" + id, gltfRuntime.scene);
  }
  if (subMaterials.length === 1) {
    material = subMaterials[0];
  }
  material._parentContainer = gltfRuntime.assetContainer;
  if (!newMesh.material) {
    newMesh.material = material;
  }
  new Geometry(id, gltfRuntime.scene, vertexData, false, newMesh);
  newMesh.computeWorldMatrix(true);
  gltfRuntime.scene._blockEntityCollection = false;
  newMesh.subMeshes = [];
  let index = 0;
  for (let meshIndex = 0; meshIndex < meshes.length; meshIndex++) {
    const meshId = meshes[meshIndex];
    const mesh = gltfRuntime.meshes[meshId];
    if (!mesh) {
      continue;
    }
    for (let i = 0; i < mesh.primitives.length; i++) {
      if (mesh.primitives[i].mode !== 4) {
      }
      SubMesh.AddToMesh(index, verticesStarts[index], verticesCounts[index], indexStarts[index], indexCounts[index], newMesh, newMesh, true);
      index++;
    }
  }
  return newMesh;
};
var configureNode = (newNode, position, rotation, scaling) => {
  if (newNode.position) {
    newNode.position = position;
  }
  if (newNode.rotationQuaternion || newNode.rotation) {
    newNode.rotationQuaternion = rotation;
  }
  if (newNode.scaling) {
    newNode.scaling = scaling;
  }
};
var configureNodeFromMatrix = (newNode, node) => {
  if (node.matrix) {
    const position = new Vector3(0, 0, 0);
    const rotation = new Quaternion();
    const scaling = new Vector3(0, 0, 0);
    const mat = Matrix.FromArray(node.matrix);
    mat.decompose(scaling, rotation, position);
    configureNode(newNode, position, rotation, scaling);
  } else if (node.translation && node.rotation && node.scale) {
    configureNode(newNode, Vector3.FromArray(node.translation), Quaternion.FromArray(node.rotation), Vector3.FromArray(node.scale));
  }
  newNode.computeWorldMatrix(true);
};
var importNode = (gltfRuntime, node, id) => {
  let lastNode = null;
  if (gltfRuntime.importOnlyMeshes && (node.skin || node.meshes)) {
    if (gltfRuntime.importMeshesNames && gltfRuntime.importMeshesNames.length > 0 && gltfRuntime.importMeshesNames.indexOf(node.name || "") === -1) {
      return null;
    }
  }
  if (node.skin) {
    if (node.meshes) {
      const skin = gltfRuntime.skins[node.skin];
      const newMesh = importMesh(gltfRuntime, node, node.meshes, id, node.babylonNode);
      newMesh.skeleton = gltfRuntime.scene.getLastSkeletonById(node.skin);
      if (newMesh.skeleton === null) {
        newMesh.skeleton = importSkeleton(gltfRuntime, skin, newMesh, skin.babylonSkeleton);
        if (!skin.babylonSkeleton) {
          skin.babylonSkeleton = newMesh.skeleton;
        }
      }
      lastNode = newMesh;
    }
  } else if (node.meshes) {
    const newMesh = importMesh(gltfRuntime, node, node.mesh ? [node.mesh] : node.meshes, id, node.babylonNode);
    lastNode = newMesh;
  } else if (node.light && !node.babylonNode && !gltfRuntime.importOnlyMeshes) {
    const light = gltfRuntime.lights[node.light];
    if (light) {
      if (light.type === "ambient") {
        const ambienLight = light[light.type];
        const hemiLight = new HemisphericLight(node.light, Vector3.Zero(), gltfRuntime.scene);
        hemiLight.name = node.name || "";
        if (ambienLight.color) {
          hemiLight.diffuse = Color3.FromArray(ambienLight.color);
        }
        lastNode = hemiLight;
      } else if (light.type === "directional") {
        const directionalLight = light[light.type];
        const dirLight = new DirectionalLight(node.light, Vector3.Zero(), gltfRuntime.scene);
        dirLight.name = node.name || "";
        if (directionalLight.color) {
          dirLight.diffuse = Color3.FromArray(directionalLight.color);
        }
        lastNode = dirLight;
      } else if (light.type === "point") {
        const pointLight = light[light.type];
        const ptLight = new PointLight(node.light, Vector3.Zero(), gltfRuntime.scene);
        ptLight.name = node.name || "";
        if (pointLight.color) {
          ptLight.diffuse = Color3.FromArray(pointLight.color);
        }
        lastNode = ptLight;
      } else if (light.type === "spot") {
        const spotLight = light[light.type];
        const spLight = new SpotLight(node.light, Vector3.Zero(), Vector3.Zero(), 0, 0, gltfRuntime.scene);
        spLight.name = node.name || "";
        if (spotLight.color) {
          spLight.diffuse = Color3.FromArray(spotLight.color);
        }
        if (spotLight.fallOfAngle) {
          spLight.angle = spotLight.fallOfAngle;
        }
        if (spotLight.fallOffExponent) {
          spLight.exponent = spotLight.fallOffExponent;
        }
        lastNode = spLight;
      }
    }
  } else if (node.camera && !node.babylonNode && !gltfRuntime.importOnlyMeshes) {
    const camera = gltfRuntime.cameras[node.camera];
    if (camera) {
      gltfRuntime.scene._blockEntityCollection = !!gltfRuntime.assetContainer;
      if (camera.type === "orthographic") {
        const orthoCamera = new FreeCamera(node.camera, Vector3.Zero(), gltfRuntime.scene, false);
        orthoCamera.name = node.name || "";
        orthoCamera.mode = Camera.ORTHOGRAPHIC_CAMERA;
        orthoCamera.attachControl();
        lastNode = orthoCamera;
        orthoCamera._parentContainer = gltfRuntime.assetContainer;
      } else if (camera.type === "perspective") {
        const perspectiveCamera = camera[camera.type];
        const persCamera = new FreeCamera(node.camera, Vector3.Zero(), gltfRuntime.scene, false);
        persCamera.name = node.name || "";
        persCamera.attachControl();
        if (!perspectiveCamera.aspectRatio) {
          perspectiveCamera.aspectRatio = gltfRuntime.scene.getEngine().getRenderWidth() / gltfRuntime.scene.getEngine().getRenderHeight();
        }
        if (perspectiveCamera.znear && perspectiveCamera.zfar) {
          persCamera.maxZ = perspectiveCamera.zfar;
          persCamera.minZ = perspectiveCamera.znear;
        }
        lastNode = persCamera;
        persCamera._parentContainer = gltfRuntime.assetContainer;
      }
      gltfRuntime.scene._blockEntityCollection = false;
    }
  }
  if (!node.jointName) {
    if (node.babylonNode) {
      return node.babylonNode;
    } else if (lastNode === null) {
      gltfRuntime.scene._blockEntityCollection = !!gltfRuntime.assetContainer;
      const dummy = new Mesh(node.name || "", gltfRuntime.scene);
      dummy._parentContainer = gltfRuntime.assetContainer;
      gltfRuntime.scene._blockEntityCollection = false;
      node.babylonNode = dummy;
      lastNode = dummy;
    }
  }
  if (lastNode !== null) {
    if (node.matrix && lastNode instanceof Mesh) {
      configureNodeFromMatrix(lastNode, node);
    } else {
      const translation = node.translation || [0, 0, 0];
      const rotation = node.rotation || [0, 0, 0, 1];
      const scale = node.scale || [1, 1, 1];
      configureNode(lastNode, Vector3.FromArray(translation), Quaternion.FromArray(rotation), Vector3.FromArray(scale));
    }
    lastNode.updateCache(true);
    node.babylonNode = lastNode;
  }
  return lastNode;
};
var traverseNodes = (gltfRuntime, id, parent, meshIncluded = false) => {
  const node = gltfRuntime.nodes[id];
  let newNode = null;
  if (gltfRuntime.importOnlyMeshes && !meshIncluded && gltfRuntime.importMeshesNames) {
    if (gltfRuntime.importMeshesNames.indexOf(node.name || "") !== -1 || gltfRuntime.importMeshesNames.length === 0) {
      meshIncluded = true;
    } else {
      meshIncluded = false;
    }
  } else {
    meshIncluded = true;
  }
  if (!node.jointName && meshIncluded) {
    newNode = importNode(gltfRuntime, node, id);
    if (newNode !== null) {
      newNode.id = id;
      newNode.parent = parent;
    }
  }
  if (node.children) {
    for (let i = 0; i < node.children.length; i++) {
      traverseNodes(gltfRuntime, node.children[i], newNode, meshIncluded);
    }
  }
};
var postLoad = (gltfRuntime) => {
  let currentScene = gltfRuntime.currentScene;
  if (currentScene) {
    for (let i = 0; i < currentScene.nodes.length; i++) {
      traverseNodes(gltfRuntime, currentScene.nodes[i], null);
    }
  } else {
    for (const thing in gltfRuntime.scenes) {
      currentScene = gltfRuntime.scenes[thing];
      for (let i = 0; i < currentScene.nodes.length; i++) {
        traverseNodes(gltfRuntime, currentScene.nodes[i], null);
      }
    }
  }
  loadAnimations(gltfRuntime);
  for (let i = 0; i < gltfRuntime.scene.skeletons.length; i++) {
    const skeleton = gltfRuntime.scene.skeletons[i];
    gltfRuntime.scene.beginAnimation(skeleton, 0, Number.MAX_VALUE, true, 1);
  }
};
var onBindShaderMaterial = (mesh, gltfRuntime, unTreatedUniforms, shaderMaterial, technique, material, onSuccess) => {
  const materialValues = material.values || technique.parameters;
  for (const unif in unTreatedUniforms) {
    const uniform = unTreatedUniforms[unif];
    const type = uniform.type;
    if (type === EParameterType.FLOAT_MAT2 || type === EParameterType.FLOAT_MAT3 || type === EParameterType.FLOAT_MAT4) {
      if (uniform.semantic && !uniform.source && !uniform.node) {
        GLTFUtils.SetMatrix(gltfRuntime.scene, mesh, uniform, unif, shaderMaterial.getEffect());
      } else if (uniform.semantic && (uniform.source || uniform.node)) {
        let source = gltfRuntime.scene.getNodeByName(uniform.source || uniform.node || "");
        if (source === null) {
          source = gltfRuntime.scene.getNodeById(uniform.source || uniform.node || "");
        }
        if (source === null) {
          continue;
        }
        GLTFUtils.SetMatrix(gltfRuntime.scene, source, uniform, unif, shaderMaterial.getEffect());
      }
    } else {
      const value = materialValues[technique.uniforms[unif]];
      if (!value) {
        continue;
      }
      if (type === EParameterType.SAMPLER_2D) {
        const texture = gltfRuntime.textures[material.values ? value : uniform.value].babylonTexture;
        if (texture === null || texture === void 0) {
          continue;
        }
        shaderMaterial.getEffect().setTexture(unif, texture);
      } else {
        GLTFUtils.SetUniform(shaderMaterial.getEffect(), unif, value, type);
      }
    }
  }
  onSuccess(shaderMaterial);
};
var prepareShaderMaterialUniforms = (gltfRuntime, shaderMaterial, technique, material, unTreatedUniforms) => {
  const materialValues = material.values || technique.parameters;
  const techniqueUniforms = technique.uniforms;
  for (const unif in unTreatedUniforms) {
    const uniform = unTreatedUniforms[unif];
    const type = uniform.type;
    let value = materialValues[techniqueUniforms[unif]];
    if (value === void 0) {
      value = uniform.value;
    }
    if (!value) {
      continue;
    }
    const onLoadTexture = (uniformName) => {
      return (texture) => {
        if (uniform.value && uniformName) {
          shaderMaterial.setTexture(uniformName, texture);
          delete unTreatedUniforms[uniformName];
        }
      };
    };
    if (type === EParameterType.SAMPLER_2D) {
      GLTFLoaderExtension.LoadTextureAsync(gltfRuntime, material.values ? value : uniform.value, onLoadTexture(unif), () => onLoadTexture(null));
    } else {
      if (uniform.value && GLTFUtils.SetUniform(shaderMaterial, unif, material.values ? value : uniform.value, type)) {
        delete unTreatedUniforms[unif];
      }
    }
  }
};
var onShaderCompileError = (program, shaderMaterial, onError) => {
  return (effect, error) => {
    shaderMaterial.dispose(true);
    onError("Cannot compile program named " + program.name + ". Error: " + error + ". Default material will be applied");
  };
};
var onShaderCompileSuccess = (gltfRuntime, shaderMaterial, technique, material, unTreatedUniforms, onSuccess) => {
  return (_) => {
    prepareShaderMaterialUniforms(gltfRuntime, shaderMaterial, technique, material, unTreatedUniforms);
    shaderMaterial.onBind = (mesh) => {
      onBindShaderMaterial(mesh, gltfRuntime, unTreatedUniforms, shaderMaterial, technique, material, onSuccess);
    };
  };
};
var parseShaderUniforms = (tokenizer, technique, unTreatedUniforms) => {
  for (const unif in technique.uniforms) {
    const uniform = technique.uniforms[unif];
    const uniformParameter = technique.parameters[uniform];
    if (tokenizer.currentIdentifier === unif) {
      if (uniformParameter.semantic && !uniformParameter.source && !uniformParameter.node) {
        const transformIndex = glTFTransforms.indexOf(uniformParameter.semantic);
        if (transformIndex !== -1) {
          delete unTreatedUniforms[unif];
          return babylonTransforms[transformIndex];
        }
      }
    }
  }
  return tokenizer.currentIdentifier;
};
var importMaterials = (gltfRuntime) => {
  for (const mat in gltfRuntime.materials) {
    GLTFLoaderExtension.LoadMaterialAsync(gltfRuntime, mat, () => {
    }, () => {
    });
  }
};
var GLTFLoaderBase = class {
  static CreateRuntime(parsedData, scene, rootUrl) {
    const gltfRuntime = {
      extensions: {},
      accessors: {},
      buffers: {},
      bufferViews: {},
      meshes: {},
      lights: {},
      cameras: {},
      nodes: {},
      images: {},
      textures: {},
      shaders: {},
      programs: {},
      samplers: {},
      techniques: {},
      materials: {},
      animations: {},
      skins: {},
      extensionsUsed: [],
      scenes: {},
      buffersCount: 0,
      shaderscount: 0,
      scene,
      rootUrl,
      loadedBufferCount: 0,
      loadedBufferViews: {},
      loadedShaderCount: 0,
      importOnlyMeshes: false,
      dummyNodes: [],
      assetContainer: null
    };
    if (parsedData.extensions) {
      parseObject(parsedData.extensions, "extensions", gltfRuntime);
    }
    if (parsedData.extensionsUsed) {
      parseObject(parsedData.extensionsUsed, "extensionsUsed", gltfRuntime);
    }
    if (parsedData.buffers) {
      parseBuffers(parsedData.buffers, gltfRuntime);
    }
    if (parsedData.bufferViews) {
      parseObject(parsedData.bufferViews, "bufferViews", gltfRuntime);
    }
    if (parsedData.accessors) {
      parseObject(parsedData.accessors, "accessors", gltfRuntime);
    }
    if (parsedData.meshes) {
      parseObject(parsedData.meshes, "meshes", gltfRuntime);
    }
    if (parsedData.lights) {
      parseObject(parsedData.lights, "lights", gltfRuntime);
    }
    if (parsedData.cameras) {
      parseObject(parsedData.cameras, "cameras", gltfRuntime);
    }
    if (parsedData.nodes) {
      parseObject(parsedData.nodes, "nodes", gltfRuntime);
    }
    if (parsedData.images) {
      parseObject(parsedData.images, "images", gltfRuntime);
    }
    if (parsedData.textures) {
      parseObject(parsedData.textures, "textures", gltfRuntime);
    }
    if (parsedData.shaders) {
      parseShaders(parsedData.shaders, gltfRuntime);
    }
    if (parsedData.programs) {
      parseObject(parsedData.programs, "programs", gltfRuntime);
    }
    if (parsedData.samplers) {
      parseObject(parsedData.samplers, "samplers", gltfRuntime);
    }
    if (parsedData.techniques) {
      parseObject(parsedData.techniques, "techniques", gltfRuntime);
    }
    if (parsedData.materials) {
      parseObject(parsedData.materials, "materials", gltfRuntime);
    }
    if (parsedData.animations) {
      parseObject(parsedData.animations, "animations", gltfRuntime);
    }
    if (parsedData.skins) {
      parseObject(parsedData.skins, "skins", gltfRuntime);
    }
    if (parsedData.scenes) {
      gltfRuntime.scenes = parsedData.scenes;
    }
    if (parsedData.scene && parsedData.scenes) {
      gltfRuntime.currentScene = parsedData.scenes[parsedData.scene];
    }
    return gltfRuntime;
  }
  static LoadBufferAsync(gltfRuntime, id, onSuccess, onError, onProgress) {
    const buffer = gltfRuntime.buffers[id];
    if (Tools.IsBase64(buffer.uri)) {
      setTimeout(() => onSuccess(new Uint8Array(Tools.DecodeBase64(buffer.uri))));
    } else {
      Tools.LoadFile(gltfRuntime.rootUrl + buffer.uri, (data) => onSuccess(new Uint8Array(data)), onProgress, void 0, true, (request) => {
        if (request) {
          onError(request.status + " " + request.statusText);
        }
      });
    }
  }
  static LoadTextureBufferAsync(gltfRuntime, id, onSuccess, onError) {
    const texture = gltfRuntime.textures[id];
    if (!texture || !texture.source) {
      onError("");
      return;
    }
    if (texture.babylonTexture) {
      onSuccess(null);
      return;
    }
    const source = gltfRuntime.images[texture.source];
    if (Tools.IsBase64(source.uri)) {
      setTimeout(() => onSuccess(new Uint8Array(Tools.DecodeBase64(source.uri))));
    } else {
      Tools.LoadFile(gltfRuntime.rootUrl + source.uri, (data) => onSuccess(new Uint8Array(data)), void 0, void 0, true, (request) => {
        if (request) {
          onError(request.status + " " + request.statusText);
        }
      });
    }
  }
  static CreateTextureAsync(gltfRuntime, id, buffer, onSuccess) {
    const texture = gltfRuntime.textures[id];
    if (texture.babylonTexture) {
      onSuccess(texture.babylonTexture);
      return;
    }
    const sampler = gltfRuntime.samplers[texture.sampler];
    const createMipMaps = sampler.minFilter === ETextureFilterType.NEAREST_MIPMAP_NEAREST || sampler.minFilter === ETextureFilterType.NEAREST_MIPMAP_LINEAR || sampler.minFilter === ETextureFilterType.LINEAR_MIPMAP_NEAREST || sampler.minFilter === ETextureFilterType.LINEAR_MIPMAP_LINEAR;
    const samplingMode = Texture.BILINEAR_SAMPLINGMODE;
    const blob = buffer == null ? new Blob() : new Blob([buffer]);
    const blobURL = URL.createObjectURL(blob);
    const revokeBlobURL = () => URL.revokeObjectURL(blobURL);
    const newTexture = new Texture(blobURL, gltfRuntime.scene, !createMipMaps, true, samplingMode, revokeBlobURL, revokeBlobURL);
    if (sampler.wrapS !== void 0) {
      newTexture.wrapU = GLTFUtils.GetWrapMode(sampler.wrapS);
    }
    if (sampler.wrapT !== void 0) {
      newTexture.wrapV = GLTFUtils.GetWrapMode(sampler.wrapT);
    }
    newTexture.name = id;
    texture.babylonTexture = newTexture;
    onSuccess(newTexture);
  }
  static LoadShaderStringAsync(gltfRuntime, id, onSuccess, onError) {
    const shader = gltfRuntime.shaders[id];
    if (Tools.IsBase64(shader.uri)) {
      const shaderString = atob(shader.uri.split(",")[1]);
      if (onSuccess) {
        onSuccess(shaderString);
      }
    } else {
      Tools.LoadFile(gltfRuntime.rootUrl + shader.uri, onSuccess, void 0, void 0, false, (request) => {
        if (request && onError) {
          onError(request.status + " " + request.statusText);
        }
      });
    }
  }
  static LoadMaterialAsync(gltfRuntime, id, onSuccess, onError) {
    const material = gltfRuntime.materials[id];
    if (!material.technique) {
      if (onError) {
        onError("No technique found.");
      }
      return;
    }
    const technique = gltfRuntime.techniques[material.technique];
    if (!technique) {
      gltfRuntime.scene._blockEntityCollection = !!gltfRuntime.assetContainer;
      const defaultMaterial = new StandardMaterial(id, gltfRuntime.scene);
      defaultMaterial._parentContainer = gltfRuntime.assetContainer;
      gltfRuntime.scene._blockEntityCollection = false;
      defaultMaterial.diffuseColor = new Color3(0.5, 0.5, 0.5);
      defaultMaterial.sideOrientation = Material.CounterClockWiseSideOrientation;
      onSuccess(defaultMaterial);
      return;
    }
    const program = gltfRuntime.programs[technique.program];
    const states = technique.states;
    const vertexShader = Effect.ShadersStore[program.vertexShader + "VertexShader"];
    const pixelShader = Effect.ShadersStore[program.fragmentShader + "PixelShader"];
    let newVertexShader = "";
    let newPixelShader = "";
    const vertexTokenizer = new Tokenizer(vertexShader);
    const pixelTokenizer = new Tokenizer(pixelShader);
    const unTreatedUniforms = {};
    const uniforms = [];
    const attributes = [];
    const samplers = [];
    for (const unif in technique.uniforms) {
      const uniform = technique.uniforms[unif];
      const uniformParameter = technique.parameters[uniform];
      unTreatedUniforms[unif] = uniformParameter;
      if (uniformParameter.semantic && !uniformParameter.node && !uniformParameter.source) {
        const transformIndex = glTFTransforms.indexOf(uniformParameter.semantic);
        if (transformIndex !== -1) {
          uniforms.push(babylonTransforms[transformIndex]);
          delete unTreatedUniforms[unif];
        } else {
          uniforms.push(unif);
        }
      } else if (uniformParameter.type === EParameterType.SAMPLER_2D) {
        samplers.push(unif);
      } else {
        uniforms.push(unif);
      }
    }
    for (const attr in technique.attributes) {
      const attribute = technique.attributes[attr];
      const attributeParameter = technique.parameters[attribute];
      if (attributeParameter.semantic) {
        const name = getAttribute(attributeParameter);
        if (name) {
          attributes.push(name);
        }
      }
    }
    while (!vertexTokenizer.isEnd() && vertexTokenizer.getNextToken()) {
      const tokenType = vertexTokenizer.currentToken;
      if (tokenType !== ETokenType.IDENTIFIER) {
        newVertexShader += vertexTokenizer.currentString;
        continue;
      }
      let foundAttribute = false;
      for (const attr in technique.attributes) {
        const attribute = technique.attributes[attr];
        const attributeParameter = technique.parameters[attribute];
        if (vertexTokenizer.currentIdentifier === attr && attributeParameter.semantic) {
          newVertexShader += getAttribute(attributeParameter);
          foundAttribute = true;
          break;
        }
      }
      if (foundAttribute) {
        continue;
      }
      newVertexShader += parseShaderUniforms(vertexTokenizer, technique, unTreatedUniforms);
    }
    while (!pixelTokenizer.isEnd() && pixelTokenizer.getNextToken()) {
      const tokenType = pixelTokenizer.currentToken;
      if (tokenType !== ETokenType.IDENTIFIER) {
        newPixelShader += pixelTokenizer.currentString;
        continue;
      }
      newPixelShader += parseShaderUniforms(pixelTokenizer, technique, unTreatedUniforms);
    }
    const shaderPath = {
      vertex: program.vertexShader + id,
      fragment: program.fragmentShader + id
    };
    const options = {
      attributes,
      uniforms,
      samplers,
      needAlphaBlending: states && states.enable && states.enable.indexOf(3042) !== -1
    };
    Effect.ShadersStore[program.vertexShader + id + "VertexShader"] = newVertexShader;
    Effect.ShadersStore[program.fragmentShader + id + "PixelShader"] = newPixelShader;
    const shaderMaterial = new ShaderMaterial(id, gltfRuntime.scene, shaderPath, options);
    shaderMaterial.onError = onShaderCompileError(program, shaderMaterial, onError);
    shaderMaterial.onCompiled = onShaderCompileSuccess(gltfRuntime, shaderMaterial, technique, material, unTreatedUniforms, onSuccess);
    shaderMaterial.sideOrientation = Material.CounterClockWiseSideOrientation;
    if (states && states.functions) {
      const functions = states.functions;
      if (functions.cullFace && functions.cullFace[0] !== ECullingType.BACK) {
        shaderMaterial.backFaceCulling = false;
      }
      const blendFunc = functions.blendFuncSeparate;
      if (blendFunc) {
        if (blendFunc[0] === EBlendingFunction.SRC_ALPHA && blendFunc[1] === EBlendingFunction.ONE_MINUS_SRC_ALPHA && blendFunc[2] === EBlendingFunction.ONE && blendFunc[3] === EBlendingFunction.ONE) {
          shaderMaterial.alphaMode = Constants.ALPHA_COMBINE;
        } else if (blendFunc[0] === EBlendingFunction.ONE && blendFunc[1] === EBlendingFunction.ONE && blendFunc[2] === EBlendingFunction.ZERO && blendFunc[3] === EBlendingFunction.ONE) {
          shaderMaterial.alphaMode = Constants.ALPHA_ONEONE;
        } else if (blendFunc[0] === EBlendingFunction.SRC_ALPHA && blendFunc[1] === EBlendingFunction.ONE && blendFunc[2] === EBlendingFunction.ZERO && blendFunc[3] === EBlendingFunction.ONE) {
          shaderMaterial.alphaMode = Constants.ALPHA_ADD;
        } else if (blendFunc[0] === EBlendingFunction.ZERO && blendFunc[1] === EBlendingFunction.ONE_MINUS_SRC_COLOR && blendFunc[2] === EBlendingFunction.ONE && blendFunc[3] === EBlendingFunction.ONE) {
          shaderMaterial.alphaMode = Constants.ALPHA_SUBTRACT;
        } else if (blendFunc[0] === EBlendingFunction.DST_COLOR && blendFunc[1] === EBlendingFunction.ZERO && blendFunc[2] === EBlendingFunction.ONE && blendFunc[3] === EBlendingFunction.ONE) {
          shaderMaterial.alphaMode = Constants.ALPHA_MULTIPLY;
        } else if (blendFunc[0] === EBlendingFunction.SRC_ALPHA && blendFunc[1] === EBlendingFunction.ONE_MINUS_SRC_COLOR && blendFunc[2] === EBlendingFunction.ONE && blendFunc[3] === EBlendingFunction.ONE) {
          shaderMaterial.alphaMode = Constants.ALPHA_MAXIMIZED;
        }
      }
    }
  }
};
var GLTFLoader = class {
  static RegisterExtension(extension) {
    if (GLTFLoader.Extensions[extension.name]) {
      Tools.Error('Tool with the same name "' + extension.name + '" already exists');
      return;
    }
    GLTFLoader.Extensions[extension.name] = extension;
  }
  dispose() {
  }
  _importMeshAsync(meshesNames, scene, data, rootUrl, assetContainer, onSuccess, onProgress, onError) {
    scene.useRightHandedSystem = true;
    GLTFLoaderExtension.LoadRuntimeAsync(scene, data, rootUrl, (gltfRuntime) => {
      gltfRuntime.assetContainer = assetContainer;
      gltfRuntime.importOnlyMeshes = true;
      if (meshesNames === "") {
        gltfRuntime.importMeshesNames = [];
      } else if (typeof meshesNames === "string") {
        gltfRuntime.importMeshesNames = [meshesNames];
      } else if (meshesNames && !(meshesNames instanceof Array)) {
        gltfRuntime.importMeshesNames = [meshesNames];
      } else {
        gltfRuntime.importMeshesNames = [];
        Tools.Warn("Argument meshesNames must be of type string or string[]");
      }
      this._createNodes(gltfRuntime);
      const meshes = new Array();
      const skeletons = new Array();
      for (const nde in gltfRuntime.nodes) {
        const node = gltfRuntime.nodes[nde];
        if (node.babylonNode instanceof AbstractMesh) {
          meshes.push(node.babylonNode);
        }
      }
      for (const skl in gltfRuntime.skins) {
        const skin = gltfRuntime.skins[skl];
        if (skin.babylonSkeleton instanceof Skeleton) {
          skeletons.push(skin.babylonSkeleton);
        }
      }
      this._loadBuffersAsync(gltfRuntime, () => {
        this._loadShadersAsync(gltfRuntime, () => {
          importMaterials(gltfRuntime);
          postLoad(gltfRuntime);
          if (!GLTFFileLoader.IncrementalLoading && onSuccess) {
            onSuccess(meshes, skeletons);
          }
        });
      });
      if (GLTFFileLoader.IncrementalLoading && onSuccess) {
        onSuccess(meshes, skeletons);
      }
    }, onError);
    return true;
  }
  importMeshAsync(meshesNames, scene, assetContainer, data, rootUrl, onProgress) {
    return new Promise((resolve, reject) => {
      this._importMeshAsync(meshesNames, scene, data, rootUrl, assetContainer, (meshes, skeletons) => {
        resolve({
          meshes,
          particleSystems: [],
          skeletons,
          animationGroups: [],
          lights: [],
          transformNodes: [],
          geometries: []
        });
      }, onProgress, (message) => {
        reject(new Error(message));
      });
    });
  }
  _loadAsync(scene, data, rootUrl, onSuccess, onProgress, onError) {
    scene.useRightHandedSystem = true;
    GLTFLoaderExtension.LoadRuntimeAsync(scene, data, rootUrl, (gltfRuntime) => {
      GLTFLoaderExtension.LoadRuntimeExtensionsAsync(gltfRuntime, () => {
        this._createNodes(gltfRuntime);
        this._loadBuffersAsync(gltfRuntime, () => {
          this._loadShadersAsync(gltfRuntime, () => {
            importMaterials(gltfRuntime);
            postLoad(gltfRuntime);
            if (!GLTFFileLoader.IncrementalLoading) {
              onSuccess();
            }
          });
        });
        if (GLTFFileLoader.IncrementalLoading) {
          onSuccess();
        }
      }, onError);
    }, onError);
  }
  loadAsync(scene, data, rootUrl, onProgress) {
    return new Promise((resolve, reject) => {
      this._loadAsync(scene, data, rootUrl, () => {
        resolve();
      }, onProgress, (message) => {
        reject(new Error(message));
      });
    });
  }
  _loadShadersAsync(gltfRuntime, onload) {
    let hasShaders = false;
    const processShader = (sha, shader) => {
      GLTFLoaderExtension.LoadShaderStringAsync(gltfRuntime, sha, (shaderString) => {
        if (shaderString instanceof ArrayBuffer) {
          return;
        }
        gltfRuntime.loadedShaderCount++;
        if (shaderString) {
          Effect.ShadersStore[sha + (shader.type === EShaderType.VERTEX ? "VertexShader" : "PixelShader")] = shaderString;
        }
        if (gltfRuntime.loadedShaderCount === gltfRuntime.shaderscount) {
          onload();
        }
      }, () => {
        Tools.Error("Error when loading shader program named " + sha + " located at " + shader.uri);
      });
    };
    for (const sha in gltfRuntime.shaders) {
      hasShaders = true;
      const shader = gltfRuntime.shaders[sha];
      if (shader) {
        processShader.bind(this, sha, shader)();
      } else {
        Tools.Error("No shader named: " + sha);
      }
    }
    if (!hasShaders) {
      onload();
    }
  }
  _loadBuffersAsync(gltfRuntime, onLoad) {
    let hasBuffers = false;
    const processBuffer = (buf, buffer) => {
      GLTFLoaderExtension.LoadBufferAsync(gltfRuntime, buf, (bufferView) => {
        gltfRuntime.loadedBufferCount++;
        if (bufferView) {
          if (bufferView.byteLength != gltfRuntime.buffers[buf].byteLength) {
            Tools.Error("Buffer named " + buf + " is length " + bufferView.byteLength + ". Expected: " + buffer.byteLength);
          }
          gltfRuntime.loadedBufferViews[buf] = bufferView;
        }
        if (gltfRuntime.loadedBufferCount === gltfRuntime.buffersCount) {
          onLoad();
        }
      }, () => {
        Tools.Error("Error when loading buffer named " + buf + " located at " + buffer.uri);
      });
    };
    for (const buf in gltfRuntime.buffers) {
      hasBuffers = true;
      const buffer = gltfRuntime.buffers[buf];
      if (buffer) {
        processBuffer.bind(this, buf, buffer)();
      } else {
        Tools.Error("No buffer named: " + buf);
      }
    }
    if (!hasBuffers) {
      onLoad();
    }
  }
  _createNodes(gltfRuntime) {
    let currentScene = gltfRuntime.currentScene;
    if (currentScene) {
      for (let i = 0; i < currentScene.nodes.length; i++) {
        traverseNodes(gltfRuntime, currentScene.nodes[i], null);
      }
    } else {
      for (const thing in gltfRuntime.scenes) {
        currentScene = gltfRuntime.scenes[thing];
        for (let i = 0; i < currentScene.nodes.length; i++) {
          traverseNodes(gltfRuntime, currentScene.nodes[i], null);
        }
      }
    }
  }
};
GLTFLoader.Extensions = {};
var GLTFLoaderExtension = class {
  constructor(name) {
    this._name = name;
  }
  get name() {
    return this._name;
  }
  loadRuntimeAsync(scene, data, rootUrl, onSuccess, onError) {
    return false;
  }
  loadRuntimeExtensionsAsync(gltfRuntime, onSuccess, onError) {
    return false;
  }
  loadBufferAsync(gltfRuntime, id, onSuccess, onError, onProgress) {
    return false;
  }
  loadTextureBufferAsync(gltfRuntime, id, onSuccess, onError) {
    return false;
  }
  createTextureAsync(gltfRuntime, id, buffer, onSuccess, onError) {
    return false;
  }
  loadShaderStringAsync(gltfRuntime, id, onSuccess, onError) {
    return false;
  }
  loadMaterialAsync(gltfRuntime, id, onSuccess, onError) {
    return false;
  }
  static LoadRuntimeAsync(scene, data, rootUrl, onSuccess, onError) {
    GLTFLoaderExtension._ApplyExtensions((loaderExtension) => {
      return loaderExtension.loadRuntimeAsync(scene, data, rootUrl, onSuccess, onError);
    }, () => {
      setTimeout(() => {
        if (!onSuccess) {
          return;
        }
        onSuccess(GLTFLoaderBase.CreateRuntime(data.json, scene, rootUrl));
      });
    });
  }
  static LoadRuntimeExtensionsAsync(gltfRuntime, onSuccess, onError) {
    GLTFLoaderExtension._ApplyExtensions((loaderExtension) => {
      return loaderExtension.loadRuntimeExtensionsAsync(gltfRuntime, onSuccess, onError);
    }, () => {
      setTimeout(() => {
        onSuccess();
      });
    });
  }
  static LoadBufferAsync(gltfRuntime, id, onSuccess, onError, onProgress) {
    GLTFLoaderExtension._ApplyExtensions((loaderExtension) => {
      return loaderExtension.loadBufferAsync(gltfRuntime, id, onSuccess, onError, onProgress);
    }, () => {
      GLTFLoaderBase.LoadBufferAsync(gltfRuntime, id, onSuccess, onError, onProgress);
    });
  }
  static LoadTextureAsync(gltfRuntime, id, onSuccess, onError) {
    GLTFLoaderExtension._LoadTextureBufferAsync(gltfRuntime, id, (buffer) => {
      if (buffer) {
        GLTFLoaderExtension._CreateTextureAsync(gltfRuntime, id, buffer, onSuccess, onError);
      }
    }, onError);
  }
  static LoadShaderStringAsync(gltfRuntime, id, onSuccess, onError) {
    GLTFLoaderExtension._ApplyExtensions((loaderExtension) => {
      return loaderExtension.loadShaderStringAsync(gltfRuntime, id, onSuccess, onError);
    }, () => {
      GLTFLoaderBase.LoadShaderStringAsync(gltfRuntime, id, onSuccess, onError);
    });
  }
  static LoadMaterialAsync(gltfRuntime, id, onSuccess, onError) {
    GLTFLoaderExtension._ApplyExtensions((loaderExtension) => {
      return loaderExtension.loadMaterialAsync(gltfRuntime, id, onSuccess, onError);
    }, () => {
      GLTFLoaderBase.LoadMaterialAsync(gltfRuntime, id, onSuccess, onError);
    });
  }
  static _LoadTextureBufferAsync(gltfRuntime, id, onSuccess, onError) {
    GLTFLoaderExtension._ApplyExtensions((loaderExtension) => {
      return loaderExtension.loadTextureBufferAsync(gltfRuntime, id, onSuccess, onError);
    }, () => {
      GLTFLoaderBase.LoadTextureBufferAsync(gltfRuntime, id, onSuccess, onError);
    });
  }
  static _CreateTextureAsync(gltfRuntime, id, buffer, onSuccess, onError) {
    GLTFLoaderExtension._ApplyExtensions((loaderExtension) => {
      return loaderExtension.createTextureAsync(gltfRuntime, id, buffer, onSuccess, onError);
    }, () => {
      GLTFLoaderBase.CreateTextureAsync(gltfRuntime, id, buffer, onSuccess);
    });
  }
  static _ApplyExtensions(func, defaultFunc) {
    for (const extensionName in GLTFLoader.Extensions) {
      const loaderExtension = GLTFLoader.Extensions[extensionName];
      if (func(loaderExtension)) {
        return;
      }
    }
    defaultFunc();
  }
};
GLTFFileLoader._CreateGLTF1Loader = () => new GLTFLoader();

// node_modules/@babylonjs/loaders/glTF/1.0/glTFBinaryExtension.js
var BinaryExtensionBufferName = "binary_glTF";
var GLTFBinaryExtension = class extends GLTFLoaderExtension {
  constructor() {
    super("KHR_binary_glTF");
  }
  loadRuntimeAsync(scene, data, rootUrl, onSuccess) {
    const extensionsUsed = data.json.extensionsUsed;
    if (!extensionsUsed || extensionsUsed.indexOf(this.name) === -1 || !data.bin) {
      return false;
    }
    this._bin = data.bin;
    onSuccess(GLTFLoaderBase.CreateRuntime(data.json, scene, rootUrl));
    return true;
  }
  loadBufferAsync(gltfRuntime, id, onSuccess, onError) {
    if (gltfRuntime.extensionsUsed.indexOf(this.name) === -1) {
      return false;
    }
    if (id !== BinaryExtensionBufferName) {
      return false;
    }
    this._bin.readAsync(0, this._bin.byteLength).then(onSuccess, (error) => onError(error.message));
    return true;
  }
  loadTextureBufferAsync(gltfRuntime, id, onSuccess) {
    const texture = gltfRuntime.textures[id];
    const source = gltfRuntime.images[texture.source];
    if (!source.extensions || !(this.name in source.extensions)) {
      return false;
    }
    const sourceExt = source.extensions[this.name];
    const bufferView = gltfRuntime.bufferViews[sourceExt.bufferView];
    const buffer = GLTFUtils.GetBufferFromBufferView(gltfRuntime, bufferView, 0, bufferView.byteLength, EComponentType.UNSIGNED_BYTE);
    onSuccess(buffer);
    return true;
  }
  loadShaderStringAsync(gltfRuntime, id, onSuccess) {
    const shader = gltfRuntime.shaders[id];
    if (!shader.extensions || !(this.name in shader.extensions)) {
      return false;
    }
    const binaryExtensionShader = shader.extensions[this.name];
    const bufferView = gltfRuntime.bufferViews[binaryExtensionShader.bufferView];
    const shaderBytes = GLTFUtils.GetBufferFromBufferView(gltfRuntime, bufferView, 0, bufferView.byteLength, EComponentType.UNSIGNED_BYTE);
    setTimeout(() => {
      const shaderString = GLTFUtils.DecodeBufferToText(shaderBytes);
      onSuccess(shaderString);
    });
    return true;
  }
};
GLTFLoader.RegisterExtension(new GLTFBinaryExtension());

// node_modules/@babylonjs/loaders/glTF/1.0/glTFMaterialsCommonExtension.js
var GLTFMaterialsCommonExtension = class extends GLTFLoaderExtension {
  constructor() {
    super("KHR_materials_common");
  }
  loadRuntimeExtensionsAsync(gltfRuntime) {
    if (!gltfRuntime.extensions) {
      return false;
    }
    const extension = gltfRuntime.extensions[this.name];
    if (!extension) {
      return false;
    }
    const lights = extension.lights;
    if (lights) {
      for (const thing in lights) {
        const light = lights[thing];
        switch (light.type) {
          case "ambient": {
            const ambientLight = new HemisphericLight(light.name, new Vector3(0, 1, 0), gltfRuntime.scene);
            const ambient = light.ambient;
            if (ambient) {
              ambientLight.diffuse = Color3.FromArray(ambient.color || [1, 1, 1]);
            }
            break;
          }
          case "point": {
            const pointLight = new PointLight(light.name, new Vector3(10, 10, 10), gltfRuntime.scene);
            const point = light.point;
            if (point) {
              pointLight.diffuse = Color3.FromArray(point.color || [1, 1, 1]);
            }
            break;
          }
          case "directional": {
            const dirLight = new DirectionalLight(light.name, new Vector3(0, -1, 0), gltfRuntime.scene);
            const directional = light.directional;
            if (directional) {
              dirLight.diffuse = Color3.FromArray(directional.color || [1, 1, 1]);
            }
            break;
          }
          case "spot": {
            const spot = light.spot;
            if (spot) {
              const spotLight = new SpotLight(light.name, new Vector3(0, 10, 0), new Vector3(0, -1, 0), spot.fallOffAngle || Math.PI, spot.fallOffExponent || 0, gltfRuntime.scene);
              spotLight.diffuse = Color3.FromArray(spot.color || [1, 1, 1]);
            }
            break;
          }
          default:
            Tools.Warn('GLTF Material Common extension: light type "' + light.type + "\u201D not supported");
            break;
        }
      }
    }
    return false;
  }
  loadMaterialAsync(gltfRuntime, id, onSuccess, onError) {
    const material = gltfRuntime.materials[id];
    if (!material || !material.extensions) {
      return false;
    }
    const extension = material.extensions[this.name];
    if (!extension) {
      return false;
    }
    const standardMaterial = new StandardMaterial(id, gltfRuntime.scene);
    standardMaterial.sideOrientation = Material.CounterClockWiseSideOrientation;
    if (extension.technique === "CONSTANT") {
      standardMaterial.disableLighting = true;
    }
    standardMaterial.backFaceCulling = extension.doubleSided === void 0 ? false : !extension.doubleSided;
    standardMaterial.alpha = extension.values.transparency === void 0 ? 1 : extension.values.transparency;
    standardMaterial.specularPower = extension.values.shininess === void 0 ? 0 : extension.values.shininess;
    if (typeof extension.values.ambient === "string") {
      this._loadTexture(gltfRuntime, extension.values.ambient, standardMaterial, "ambientTexture", onError);
    } else {
      standardMaterial.ambientColor = Color3.FromArray(extension.values.ambient || [0, 0, 0]);
    }
    if (typeof extension.values.diffuse === "string") {
      this._loadTexture(gltfRuntime, extension.values.diffuse, standardMaterial, "diffuseTexture", onError);
    } else {
      standardMaterial.diffuseColor = Color3.FromArray(extension.values.diffuse || [0, 0, 0]);
    }
    if (typeof extension.values.emission === "string") {
      this._loadTexture(gltfRuntime, extension.values.emission, standardMaterial, "emissiveTexture", onError);
    } else {
      standardMaterial.emissiveColor = Color3.FromArray(extension.values.emission || [0, 0, 0]);
    }
    if (typeof extension.values.specular === "string") {
      this._loadTexture(gltfRuntime, extension.values.specular, standardMaterial, "specularTexture", onError);
    } else {
      standardMaterial.specularColor = Color3.FromArray(extension.values.specular || [0, 0, 0]);
    }
    return true;
  }
  _loadTexture(gltfRuntime, id, material, propertyPath, onError) {
    GLTFLoaderBase.LoadTextureBufferAsync(gltfRuntime, id, (buffer) => {
      GLTFLoaderBase.CreateTextureAsync(gltfRuntime, id, buffer, (texture) => material[propertyPath] = texture);
    }, onError);
  }
};
GLTFLoader.RegisterExtension(new GLTFMaterialsCommonExtension());

// node_modules/@babylonjs/loaders/glTF/2.0/index.js
var __exports2 = {};
__export(__exports2, {
  ArrayItem: () => ArrayItem,
  EXT_lights_image_based: () => EXT_lights_image_based,
  EXT_mesh_gpu_instancing: () => EXT_mesh_gpu_instancing,
  EXT_meshopt_compression: () => EXT_meshopt_compression,
  EXT_texture_webp: () => EXT_texture_webp,
  ExtrasAsMetadata: () => ExtrasAsMetadata,
  GLTFLoader: () => GLTFLoader2,
  KHR_animation_pointer: () => KHR_animation_pointer,
  KHR_draco_mesh_compression: () => KHR_draco_mesh_compression,
  KHR_lights: () => KHR_lights,
  KHR_materials_clearcoat: () => KHR_materials_clearcoat,
  KHR_materials_emissive_strength: () => KHR_materials_emissive_strength,
  KHR_materials_ior: () => KHR_materials_ior,
  KHR_materials_iridescence: () => KHR_materials_iridescence,
  KHR_materials_pbrSpecularGlossiness: () => KHR_materials_pbrSpecularGlossiness,
  KHR_materials_sheen: () => KHR_materials_sheen,
  KHR_materials_specular: () => KHR_materials_specular,
  KHR_materials_translucency: () => KHR_materials_translucency,
  KHR_materials_transmission: () => KHR_materials_transmission,
  KHR_materials_unlit: () => KHR_materials_unlit,
  KHR_materials_variants: () => KHR_materials_variants,
  KHR_materials_volume: () => KHR_materials_volume,
  KHR_mesh_quantization: () => KHR_mesh_quantization,
  KHR_texture_basisu: () => KHR_texture_basisu,
  KHR_texture_transform: () => KHR_texture_transform,
  KHR_xmp_json_ld: () => KHR_xmp_json_ld,
  MSFT_audio_emitter: () => MSFT_audio_emitter,
  MSFT_lod: () => MSFT_lod,
  MSFT_minecraftMesh: () => MSFT_minecraftMesh,
  MSFT_sRGBFactors: () => MSFT_sRGBFactors
});

// node_modules/@babylonjs/loaders/glTF/2.0/glTFLoaderAnimation.js
function getVector3(_target, source, offset, scale) {
  return Vector3.FromArray(source, offset).scaleInPlace(scale);
}
function getQuaternion(_target, source, offset, scale) {
  return Quaternion.FromArray(source, offset).scaleInPlace(scale);
}
function getWeights(target, source, offset, scale) {
  const value = new Array(target._numMorphTargets);
  for (let i = 0; i < value.length; i++) {
    value[i] = source[offset++] * scale;
  }
  return value;
}
var AnimationPropertyInfo = class {
  constructor(type, name, getValue, getStride) {
    this.type = type;
    this.name = name;
    this.getValue = getValue;
    this.getStride = getStride;
  }
  _buildAnimation(name, fps, keys) {
    const babylonAnimation = new Animation(name, this.name, fps, this.type);
    babylonAnimation.setKeys(keys);
    return babylonAnimation;
  }
};
var TransformNodeAnimationPropertyInfo = class extends AnimationPropertyInfo {
  buildAnimations(target, name, fps, keys, callback) {
    callback(target._babylonTransformNode, this._buildAnimation(name, fps, keys));
  }
};
var WeightAnimationPropertyInfo = class extends AnimationPropertyInfo {
  buildAnimations(target, name, fps, keys, callback) {
    if (target._numMorphTargets) {
      for (let targetIndex = 0; targetIndex < target._numMorphTargets; targetIndex++) {
        const babylonAnimation = new Animation(`${name}_${targetIndex}`, this.name, fps, this.type);
        babylonAnimation.setKeys(keys.map((key) => ({
          frame: key.frame,
          inTangent: key.inTangent ? key.inTangent[targetIndex] : void 0,
          value: key.value[targetIndex],
          outTangent: key.outTangent ? key.outTangent[targetIndex] : void 0,
          interpolation: key.interpolation
        })));
        if (target._primitiveBabylonMeshes) {
          for (const babylonMesh of target._primitiveBabylonMeshes) {
            if (babylonMesh.morphTargetManager) {
              const morphTarget = babylonMesh.morphTargetManager.getTarget(targetIndex);
              const babylonAnimationClone = babylonAnimation.clone();
              morphTarget.animations.push(babylonAnimationClone);
              callback(morphTarget, babylonAnimationClone);
            }
          }
        }
      }
    }
  }
};
var nodeAnimationData = {
  translation: [new TransformNodeAnimationPropertyInfo(Animation.ANIMATIONTYPE_VECTOR3, "position", getVector3, () => 3)],
  rotation: [new TransformNodeAnimationPropertyInfo(Animation.ANIMATIONTYPE_QUATERNION, "rotationQuaternion", getQuaternion, () => 4)],
  scale: [new TransformNodeAnimationPropertyInfo(Animation.ANIMATIONTYPE_VECTOR3, "scaling", getVector3, () => 3)],
  weights: [new WeightAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, "influence", getWeights, (target) => target._numMorphTargets)]
};

// node_modules/@babylonjs/loaders/glTF/2.0/glTFLoader.js
function mergeDeep(...objects) {
  const isObject = (obj) => obj && typeof obj === "object";
  return objects.reduce((prev, obj) => {
    Object.keys(obj).forEach((key) => {
      const pVal = prev[key];
      const oVal = obj[key];
      if (Array.isArray(pVal) && Array.isArray(oVal)) {
        prev[key] = pVal.concat(...oVal);
      } else if (isObject(pVal) && isObject(oVal)) {
        prev[key] = mergeDeep(pVal, oVal);
      } else {
        prev[key] = oVal;
      }
    });
    return prev;
  }, {});
}
var ArrayItem = class {
  static Get(context, array, index) {
    if (!array || index == void 0 || !array[index]) {
      throw new Error(`${context}: Failed to find index (${index})`);
    }
    return array[index];
  }
  static Assign(array) {
    if (array) {
      for (let index = 0; index < array.length; index++) {
        array[index].index = index;
      }
    }
  }
};
var GLTFLoader2 = class {
  constructor(parent) {
    this._completePromises = new Array();
    this._assetContainer = null;
    this._babylonLights = [];
    this._disableInstancedMesh = 0;
    this._extensions = new Array();
    this._disposed = false;
    this._rootUrl = null;
    this._fileName = null;
    this._uniqueRootUrl = null;
    this._bin = null;
    this._rootBabylonMesh = null;
    this._defaultBabylonMaterialData = {};
    this._postSceneLoadActions = new Array();
    this._parent = parent;
  }
  static RegisterExtension(name, factory) {
    if (GLTFLoader2.UnregisterExtension(name)) {
      Logger.Warn(`Extension with the name '${name}' already exists`);
    }
    GLTFLoader2._RegisteredExtensions[name] = {
      factory
    };
  }
  static UnregisterExtension(name) {
    if (!GLTFLoader2._RegisteredExtensions[name]) {
      return false;
    }
    delete GLTFLoader2._RegisteredExtensions[name];
    return true;
  }
  get gltf() {
    if (!this._gltf) {
      throw new Error("glTF JSON is not available");
    }
    return this._gltf;
  }
  get bin() {
    return this._bin;
  }
  get parent() {
    return this._parent;
  }
  get babylonScene() {
    if (!this._babylonScene) {
      throw new Error("Scene is not available");
    }
    return this._babylonScene;
  }
  get rootBabylonMesh() {
    return this._rootBabylonMesh;
  }
  dispose() {
    if (this._disposed) {
      return;
    }
    this._disposed = true;
    this._completePromises.length = 0;
    this._extensions.forEach((extension) => extension.dispose && extension.dispose());
    this._extensions.length = 0;
    this._gltf = null;
    this._bin = null;
    this._babylonScene = null;
    this._rootBabylonMesh = null;
    this._defaultBabylonMaterialData = {};
    this._postSceneLoadActions.length = 0;
    this._parent.dispose();
  }
  importMeshAsync(meshesNames, scene, container, data, rootUrl, onProgress, fileName = "") {
    return Promise.resolve().then(() => {
      this._babylonScene = scene;
      this._assetContainer = container;
      this._loadData(data);
      let nodes = null;
      if (meshesNames) {
        const nodeMap = {};
        if (this._gltf.nodes) {
          for (const node of this._gltf.nodes) {
            if (node.name) {
              nodeMap[node.name] = node.index;
            }
          }
        }
        const names = meshesNames instanceof Array ? meshesNames : [meshesNames];
        nodes = names.map((name) => {
          const node = nodeMap[name];
          if (node === void 0) {
            throw new Error(`Failed to find node '${name}'`);
          }
          return node;
        });
      }
      return this._loadAsync(rootUrl, fileName, nodes, () => {
        return {
          meshes: this._getMeshes(),
          particleSystems: [],
          skeletons: this._getSkeletons(),
          animationGroups: this._getAnimationGroups(),
          lights: this._babylonLights,
          transformNodes: this._getTransformNodes(),
          geometries: this._getGeometries()
        };
      });
    });
  }
  loadAsync(scene, data, rootUrl, onProgress, fileName = "") {
    return Promise.resolve().then(() => {
      this._babylonScene = scene;
      this._loadData(data);
      return this._loadAsync(rootUrl, fileName, null, () => void 0);
    });
  }
  _loadAsync(rootUrl, fileName, nodes, resultFunc) {
    return Promise.resolve().then(() => {
      this._rootUrl = rootUrl;
      this._uniqueRootUrl = !rootUrl.startsWith("file:") && fileName ? rootUrl : `${rootUrl}${Date.now()}/`;
      this._fileName = fileName;
      this._loadExtensions();
      this._checkExtensions();
      const loadingToReadyCounterName = `${GLTFLoaderState[GLTFLoaderState.LOADING]} => ${GLTFLoaderState[GLTFLoaderState.READY]}`;
      const loadingToCompleteCounterName = `${GLTFLoaderState[GLTFLoaderState.LOADING]} => ${GLTFLoaderState[GLTFLoaderState.COMPLETE]}`;
      this._parent._startPerformanceCounter(loadingToReadyCounterName);
      this._parent._startPerformanceCounter(loadingToCompleteCounterName);
      this._parent._setState(GLTFLoaderState.LOADING);
      this._extensionsOnLoading();
      const promises = new Array();
      const oldBlockMaterialDirtyMechanism = this._babylonScene.blockMaterialDirtyMechanism;
      this._babylonScene.blockMaterialDirtyMechanism = true;
      if (!this.parent.loadOnlyMaterials) {
        if (nodes) {
          promises.push(this.loadSceneAsync("/nodes", { nodes, index: -1 }));
        } else if (this._gltf.scene != void 0 || this._gltf.scenes && this._gltf.scenes[0]) {
          const scene = ArrayItem.Get(`/scene`, this._gltf.scenes, this._gltf.scene || 0);
          promises.push(this.loadSceneAsync(`/scenes/${scene.index}`, scene));
        }
      }
      if (!this.parent.skipMaterials && this.parent.loadAllMaterials && this._gltf.materials) {
        for (let m = 0; m < this._gltf.materials.length; ++m) {
          const material = this._gltf.materials[m];
          const context = "/materials/" + m;
          const babylonDrawMode = Material.TriangleFillMode;
          promises.push(this._loadMaterialAsync(context, material, null, babylonDrawMode, () => {
          }));
        }
      }
      this._babylonScene.blockMaterialDirtyMechanism = oldBlockMaterialDirtyMechanism;
      if (this._parent.compileMaterials) {
        promises.push(this._compileMaterialsAsync());
      }
      if (this._parent.compileShadowGenerators) {
        promises.push(this._compileShadowGeneratorsAsync());
      }
      const resultPromise = Promise.all(promises).then(() => {
        if (this._rootBabylonMesh) {
          this._rootBabylonMesh.setEnabled(true);
        }
        this._extensionsOnReady();
        this._parent._setState(GLTFLoaderState.READY);
        this._startAnimations();
        return resultFunc();
      });
      return resultPromise.then((result) => {
        this._parent._endPerformanceCounter(loadingToReadyCounterName);
        Tools.SetImmediate(() => {
          if (!this._disposed) {
            Promise.all(this._completePromises).then(() => {
              this._parent._endPerformanceCounter(loadingToCompleteCounterName);
              this._parent._setState(GLTFLoaderState.COMPLETE);
              this._parent.onCompleteObservable.notifyObservers(void 0);
              this._parent.onCompleteObservable.clear();
              this.dispose();
            }, (error) => {
              this._parent.onErrorObservable.notifyObservers(error);
              this._parent.onErrorObservable.clear();
              this.dispose();
            });
          }
        });
        return result;
      });
    }).catch((error) => {
      if (!this._disposed) {
        this._parent.onErrorObservable.notifyObservers(error);
        this._parent.onErrorObservable.clear();
        this.dispose();
      }
      throw error;
    });
  }
  _loadData(data) {
    this._gltf = data.json;
    this._setupData();
    if (data.bin) {
      const buffers = this._gltf.buffers;
      if (buffers && buffers[0] && !buffers[0].uri) {
        const binaryBuffer = buffers[0];
        if (binaryBuffer.byteLength < data.bin.byteLength - 3 || binaryBuffer.byteLength > data.bin.byteLength) {
          Logger.Warn(`Binary buffer length (${binaryBuffer.byteLength}) from JSON does not match chunk length (${data.bin.byteLength})`);
        }
        this._bin = data.bin;
      } else {
        Logger.Warn("Unexpected BIN chunk");
      }
    }
  }
  _setupData() {
    ArrayItem.Assign(this._gltf.accessors);
    ArrayItem.Assign(this._gltf.animations);
    ArrayItem.Assign(this._gltf.buffers);
    ArrayItem.Assign(this._gltf.bufferViews);
    ArrayItem.Assign(this._gltf.cameras);
    ArrayItem.Assign(this._gltf.images);
    ArrayItem.Assign(this._gltf.materials);
    ArrayItem.Assign(this._gltf.meshes);
    ArrayItem.Assign(this._gltf.nodes);
    ArrayItem.Assign(this._gltf.samplers);
    ArrayItem.Assign(this._gltf.scenes);
    ArrayItem.Assign(this._gltf.skins);
    ArrayItem.Assign(this._gltf.textures);
    if (this._gltf.nodes) {
      const nodeParents = {};
      for (const node of this._gltf.nodes) {
        if (node.children) {
          for (const index of node.children) {
            nodeParents[index] = node.index;
          }
        }
      }
      const rootNode = this._createRootNode();
      for (const node of this._gltf.nodes) {
        const parentIndex = nodeParents[node.index];
        node.parent = parentIndex === void 0 ? rootNode : this._gltf.nodes[parentIndex];
      }
    }
  }
  _loadExtensions() {
    for (const name in GLTFLoader2._RegisteredExtensions) {
      const extension = GLTFLoader2._RegisteredExtensions[name].factory(this);
      if (extension.name !== name) {
        Logger.Warn(`The name of the glTF loader extension instance does not match the registered name: ${extension.name} !== ${name}`);
      }
      this._extensions.push(extension);
      this._parent.onExtensionLoadedObservable.notifyObservers(extension);
    }
    this._extensions.sort((a, b) => (a.order || Number.MAX_VALUE) - (b.order || Number.MAX_VALUE));
    this._parent.onExtensionLoadedObservable.clear();
  }
  _checkExtensions() {
    if (this._gltf.extensionsRequired) {
      for (const name of this._gltf.extensionsRequired) {
        const available = this._extensions.some((extension) => extension.name === name && extension.enabled);
        if (!available) {
          throw new Error(`Require extension ${name} is not available`);
        }
      }
    }
  }
  _createRootNode() {
    this._babylonScene._blockEntityCollection = !!this._assetContainer;
    this._rootBabylonMesh = new Mesh("__root__", this._babylonScene);
    this._rootBabylonMesh._parentContainer = this._assetContainer;
    this._babylonScene._blockEntityCollection = false;
    this._rootBabylonMesh.setEnabled(false);
    const rootNode = {
      _babylonTransformNode: this._rootBabylonMesh,
      index: -1
    };
    switch (this._parent.coordinateSystemMode) {
      case GLTFLoaderCoordinateSystemMode.AUTO: {
        if (!this._babylonScene.useRightHandedSystem) {
          rootNode.rotation = [0, 1, 0, 0];
          rootNode.scale = [1, 1, -1];
          GLTFLoader2._LoadTransform(rootNode, this._rootBabylonMesh);
        }
        break;
      }
      case GLTFLoaderCoordinateSystemMode.FORCE_RIGHT_HANDED: {
        this._babylonScene.useRightHandedSystem = true;
        break;
      }
      default: {
        throw new Error(`Invalid coordinate system mode (${this._parent.coordinateSystemMode})`);
      }
    }
    this._parent.onMeshLoadedObservable.notifyObservers(this._rootBabylonMesh);
    return rootNode;
  }
  loadSceneAsync(context, scene) {
    const extensionPromise = this._extensionsLoadSceneAsync(context, scene);
    if (extensionPromise) {
      return extensionPromise;
    }
    const promises = new Array();
    this.logOpen(`${context} ${scene.name || ""}`);
    if (scene.nodes) {
      for (const index of scene.nodes) {
        const node = ArrayItem.Get(`${context}/nodes/${index}`, this._gltf.nodes, index);
        promises.push(this.loadNodeAsync(`/nodes/${node.index}`, node, (babylonMesh) => {
          babylonMesh.parent = this._rootBabylonMesh;
        }));
      }
    }
    for (const action of this._postSceneLoadActions) {
      action();
    }
    promises.push(this._loadAnimationsAsync());
    this.logClose();
    return Promise.all(promises).then(() => {
    });
  }
  _forEachPrimitive(node, callback) {
    if (node._primitiveBabylonMeshes) {
      for (const babylonMesh of node._primitiveBabylonMeshes) {
        callback(babylonMesh);
      }
    }
  }
  _getGeometries() {
    const geometries = new Array();
    const nodes = this._gltf.nodes;
    if (nodes) {
      for (const node of nodes) {
        this._forEachPrimitive(node, (babylonMesh) => {
          const geometry = babylonMesh.geometry;
          if (geometry && geometries.indexOf(geometry) === -1) {
            geometries.push(geometry);
          }
        });
      }
    }
    return geometries;
  }
  _getMeshes() {
    const meshes = new Array();
    if (this._rootBabylonMesh) {
      meshes.push(this._rootBabylonMesh);
    }
    const nodes = this._gltf.nodes;
    if (nodes) {
      for (const node of nodes) {
        this._forEachPrimitive(node, (babylonMesh) => {
          meshes.push(babylonMesh);
        });
      }
    }
    return meshes;
  }
  _getTransformNodes() {
    const transformNodes = new Array();
    const nodes = this._gltf.nodes;
    if (nodes) {
      for (const node of nodes) {
        if (node._babylonTransformNode && node._babylonTransformNode.getClassName() === "TransformNode") {
          transformNodes.push(node._babylonTransformNode);
        }
        if (node._babylonTransformNodeForSkin) {
          transformNodes.push(node._babylonTransformNodeForSkin);
        }
      }
    }
    return transformNodes;
  }
  _getSkeletons() {
    const skeletons = new Array();
    const skins = this._gltf.skins;
    if (skins) {
      for (const skin of skins) {
        if (skin._data) {
          skeletons.push(skin._data.babylonSkeleton);
        }
      }
    }
    return skeletons;
  }
  _getAnimationGroups() {
    const animationGroups = new Array();
    const animations = this._gltf.animations;
    if (animations) {
      for (const animation of animations) {
        if (animation._babylonAnimationGroup) {
          animationGroups.push(animation._babylonAnimationGroup);
        }
      }
    }
    return animationGroups;
  }
  _startAnimations() {
    switch (this._parent.animationStartMode) {
      case GLTFLoaderAnimationStartMode.NONE: {
        break;
      }
      case GLTFLoaderAnimationStartMode.FIRST: {
        const babylonAnimationGroups = this._getAnimationGroups();
        if (babylonAnimationGroups.length !== 0) {
          babylonAnimationGroups[0].start(true);
        }
        break;
      }
      case GLTFLoaderAnimationStartMode.ALL: {
        const babylonAnimationGroups = this._getAnimationGroups();
        for (const babylonAnimationGroup of babylonAnimationGroups) {
          babylonAnimationGroup.start(true);
        }
        break;
      }
      default: {
        Logger.Error(`Invalid animation start mode (${this._parent.animationStartMode})`);
        return;
      }
    }
  }
  loadNodeAsync(context, node, assign = () => {
  }) {
    const extensionPromise = this._extensionsLoadNodeAsync(context, node, assign);
    if (extensionPromise) {
      return extensionPromise;
    }
    if (node._babylonTransformNode) {
      throw new Error(`${context}: Invalid recursive node hierarchy`);
    }
    const promises = new Array();
    this.logOpen(`${context} ${node.name || ""}`);
    const loadNode = (babylonTransformNode) => {
      GLTFLoader2.AddPointerMetadata(babylonTransformNode, context);
      GLTFLoader2._LoadTransform(node, babylonTransformNode);
      if (node.camera != void 0) {
        const camera = ArrayItem.Get(`${context}/camera`, this._gltf.cameras, node.camera);
        promises.push(this.loadCameraAsync(`/cameras/${camera.index}`, camera, (babylonCamera) => {
          babylonCamera.parent = babylonTransformNode;
        }));
      }
      if (node.children) {
        for (const index of node.children) {
          const childNode = ArrayItem.Get(`${context}/children/${index}`, this._gltf.nodes, index);
          promises.push(this.loadNodeAsync(`/nodes/${childNode.index}`, childNode, (childBabylonMesh) => {
            childBabylonMesh.parent = babylonTransformNode;
          }));
        }
      }
      assign(babylonTransformNode);
    };
    if (node.mesh == void 0 || node.skin != void 0) {
      const nodeName = node.name || `node${node.index}`;
      this._babylonScene._blockEntityCollection = !!this._assetContainer;
      const transformNode = new TransformNode(nodeName, this._babylonScene);
      transformNode._parentContainer = this._assetContainer;
      this._babylonScene._blockEntityCollection = false;
      if (node.mesh == void 0) {
        node._babylonTransformNode = transformNode;
      } else {
        node._babylonTransformNodeForSkin = transformNode;
      }
      loadNode(transformNode);
    }
    if (node.mesh != void 0) {
      if (node.skin == void 0) {
        const mesh = ArrayItem.Get(`${context}/mesh`, this._gltf.meshes, node.mesh);
        promises.push(this._loadMeshAsync(`/meshes/${mesh.index}`, node, mesh, loadNode));
      } else {
        const mesh = ArrayItem.Get(`${context}/mesh`, this._gltf.meshes, node.mesh);
        promises.push(this._loadMeshAsync(`/meshes/${mesh.index}`, node, mesh, (babylonTransformNode) => {
          const babylonTransformNodeForSkin = node._babylonTransformNodeForSkin;
          babylonTransformNode.metadata = mergeDeep(babylonTransformNodeForSkin.metadata, babylonTransformNode.metadata || {});
          const skin = ArrayItem.Get(`${context}/skin`, this._gltf.skins, node.skin);
          promises.push(this._loadSkinAsync(`/skins/${skin.index}`, node, skin, (babylonSkeleton) => {
            this._forEachPrimitive(node, (babylonMesh) => {
              babylonMesh.skeleton = babylonSkeleton;
            });
            this._postSceneLoadActions.push(() => {
              if (skin.skeleton != void 0) {
                const parentNode = ArrayItem.Get(`/skins/${skin.index}/skeleton`, this._gltf.nodes, skin.skeleton).parent;
                if (node.index === parentNode.index) {
                  babylonTransformNode.parent = babylonTransformNodeForSkin.parent;
                } else {
                  babylonTransformNode.parent = parentNode._babylonTransformNode;
                }
              } else {
                babylonTransformNode.parent = this._rootBabylonMesh;
              }
              this._parent.onSkinLoadedObservable.notifyObservers({ node: babylonTransformNodeForSkin, skinnedNode: babylonTransformNode });
            });
          }));
        }));
      }
    }
    this.logClose();
    return Promise.all(promises).then(() => {
      this._forEachPrimitive(node, (babylonMesh) => {
        if (babylonMesh.geometry && babylonMesh.geometry.useBoundingInfoFromGeometry) {
          babylonMesh._updateBoundingInfo();
        } else {
          babylonMesh.refreshBoundingInfo(true);
        }
      });
      return node._babylonTransformNode;
    });
  }
  _loadMeshAsync(context, node, mesh, assign) {
    const primitives = mesh.primitives;
    if (!primitives || !primitives.length) {
      throw new Error(`${context}: Primitives are missing`);
    }
    if (primitives[0].index == void 0) {
      ArrayItem.Assign(primitives);
    }
    const promises = new Array();
    this.logOpen(`${context} ${mesh.name || ""}`);
    const name = node.name || `node${node.index}`;
    if (primitives.length === 1) {
      const primitive = mesh.primitives[0];
      promises.push(this._loadMeshPrimitiveAsync(`${context}/primitives/${primitive.index}`, name, node, mesh, primitive, (babylonMesh) => {
        node._babylonTransformNode = babylonMesh;
        node._primitiveBabylonMeshes = [babylonMesh];
      }));
    } else {
      this._babylonScene._blockEntityCollection = !!this._assetContainer;
      node._babylonTransformNode = new TransformNode(name, this._babylonScene);
      node._babylonTransformNode._parentContainer = this._assetContainer;
      this._babylonScene._blockEntityCollection = false;
      node._primitiveBabylonMeshes = [];
      for (const primitive of primitives) {
        promises.push(this._loadMeshPrimitiveAsync(`${context}/primitives/${primitive.index}`, `${name}_primitive${primitive.index}`, node, mesh, primitive, (babylonMesh) => {
          babylonMesh.parent = node._babylonTransformNode;
          node._primitiveBabylonMeshes.push(babylonMesh);
        }));
      }
    }
    assign(node._babylonTransformNode);
    this.logClose();
    return Promise.all(promises).then(() => {
      return node._babylonTransformNode;
    });
  }
  _loadMeshPrimitiveAsync(context, name, node, mesh, primitive, assign) {
    const extensionPromise = this._extensionsLoadMeshPrimitiveAsync(context, name, node, mesh, primitive, assign);
    if (extensionPromise) {
      return extensionPromise;
    }
    this.logOpen(`${context}`);
    const shouldInstance = this._disableInstancedMesh === 0 && this._parent.createInstances && node.skin == void 0 && !mesh.primitives[0].targets;
    let babylonAbstractMesh;
    let promise;
    if (shouldInstance && primitive._instanceData) {
      this._babylonScene._blockEntityCollection = !!this._assetContainer;
      babylonAbstractMesh = primitive._instanceData.babylonSourceMesh.createInstance(name);
      babylonAbstractMesh._parentContainer = this._assetContainer;
      this._babylonScene._blockEntityCollection = false;
      promise = primitive._instanceData.promise;
    } else {
      const promises = new Array();
      this._babylonScene._blockEntityCollection = !!this._assetContainer;
      const babylonMesh = new Mesh(name, this._babylonScene);
      babylonMesh._parentContainer = this._assetContainer;
      this._babylonScene._blockEntityCollection = false;
      babylonMesh.overrideMaterialSideOrientation = this._babylonScene.useRightHandedSystem ? Material.CounterClockWiseSideOrientation : Material.ClockWiseSideOrientation;
      this._createMorphTargets(context, node, mesh, primitive, babylonMesh);
      promises.push(this._loadVertexDataAsync(context, primitive, babylonMesh).then((babylonGeometry) => {
        return this._loadMorphTargetsAsync(context, primitive, babylonMesh, babylonGeometry).then(() => {
          if (this._disposed) {
            return;
          }
          this._babylonScene._blockEntityCollection = !!this._assetContainer;
          babylonGeometry.applyToMesh(babylonMesh);
          babylonGeometry._parentContainer = this._assetContainer;
          this._babylonScene._blockEntityCollection = false;
        });
      }));
      const babylonDrawMode = GLTFLoader2._GetDrawMode(context, primitive.mode);
      if (primitive.material == void 0) {
        let babylonMaterial = this._defaultBabylonMaterialData[babylonDrawMode];
        if (!babylonMaterial) {
          babylonMaterial = this._createDefaultMaterial("__GLTFLoader._default", babylonDrawMode);
          this._parent.onMaterialLoadedObservable.notifyObservers(babylonMaterial);
          this._defaultBabylonMaterialData[babylonDrawMode] = babylonMaterial;
        }
        babylonMesh.material = babylonMaterial;
      } else if (!this.parent.skipMaterials) {
        const material = ArrayItem.Get(`${context}/material`, this._gltf.materials, primitive.material);
        promises.push(this._loadMaterialAsync(`/materials/${material.index}`, material, babylonMesh, babylonDrawMode, (babylonMaterial) => {
          babylonMesh.material = babylonMaterial;
        }));
      }
      promise = Promise.all(promises);
      if (shouldInstance) {
        primitive._instanceData = {
          babylonSourceMesh: babylonMesh,
          promise
        };
      }
      babylonAbstractMesh = babylonMesh;
    }
    GLTFLoader2.AddPointerMetadata(babylonAbstractMesh, context);
    this._parent.onMeshLoadedObservable.notifyObservers(babylonAbstractMesh);
    assign(babylonAbstractMesh);
    this.logClose();
    return promise.then(() => {
      return babylonAbstractMesh;
    });
  }
  _loadVertexDataAsync(context, primitive, babylonMesh) {
    const extensionPromise = this._extensionsLoadVertexDataAsync(context, primitive, babylonMesh);
    if (extensionPromise) {
      return extensionPromise;
    }
    const attributes = primitive.attributes;
    if (!attributes) {
      throw new Error(`${context}: Attributes are missing`);
    }
    const promises = new Array();
    const babylonGeometry = new Geometry(babylonMesh.name, this._babylonScene);
    if (primitive.indices == void 0) {
      babylonMesh.isUnIndexed = true;
    } else {
      const accessor = ArrayItem.Get(`${context}/indices`, this._gltf.accessors, primitive.indices);
      promises.push(this._loadIndicesAccessorAsync(`/accessors/${accessor.index}`, accessor).then((data) => {
        babylonGeometry.setIndices(data);
      }));
    }
    const loadAttribute = (attribute, kind, callback) => {
      if (attributes[attribute] == void 0) {
        return;
      }
      babylonMesh._delayInfo = babylonMesh._delayInfo || [];
      if (babylonMesh._delayInfo.indexOf(kind) === -1) {
        babylonMesh._delayInfo.push(kind);
      }
      const accessor = ArrayItem.Get(`${context}/attributes/${attribute}`, this._gltf.accessors, attributes[attribute]);
      promises.push(this._loadVertexAccessorAsync(`/accessors/${accessor.index}`, accessor, kind).then((babylonVertexBuffer) => {
        if (babylonVertexBuffer.getKind() === VertexBuffer.PositionKind && !this.parent.alwaysComputeBoundingBox && !babylonMesh.skeleton) {
          const mmin = accessor.min, mmax = accessor.max;
          if (mmin !== void 0 && mmax !== void 0) {
            if (accessor.normalized && accessor.componentType !== 5126) {
              let divider = 1;
              switch (accessor.componentType) {
                case 5120:
                  divider = 127;
                  break;
                case 5121:
                  divider = 255;
                  break;
                case 5122:
                  divider = 32767;
                  break;
                case 5123:
                  divider = 65535;
                  break;
              }
              for (let i = 0; i < 3; ++i) {
                mmin[i] = Math.max(mmin[i] / divider, -1);
                mmax[i] = Math.max(mmax[i] / divider, -1);
              }
            }
            const min = TmpVectors.Vector3[0], max = TmpVectors.Vector3[1];
            min.copyFromFloats(...mmin);
            max.copyFromFloats(...mmax);
            babylonGeometry._boundingInfo = new BoundingInfo(min, max);
            babylonGeometry.useBoundingInfoFromGeometry = true;
          }
        }
        babylonGeometry.setVerticesBuffer(babylonVertexBuffer, accessor.count);
      }));
      if (kind == VertexBuffer.MatricesIndicesExtraKind) {
        babylonMesh.numBoneInfluencers = 8;
      }
      if (callback) {
        callback(accessor);
      }
    };
    loadAttribute("POSITION", VertexBuffer.PositionKind);
    loadAttribute("NORMAL", VertexBuffer.NormalKind);
    loadAttribute("TANGENT", VertexBuffer.TangentKind);
    loadAttribute("TEXCOORD_0", VertexBuffer.UVKind);
    loadAttribute("TEXCOORD_1", VertexBuffer.UV2Kind);
    loadAttribute("TEXCOORD_2", VertexBuffer.UV3Kind);
    loadAttribute("TEXCOORD_3", VertexBuffer.UV4Kind);
    loadAttribute("TEXCOORD_4", VertexBuffer.UV5Kind);
    loadAttribute("TEXCOORD_5", VertexBuffer.UV6Kind);
    loadAttribute("JOINTS_0", VertexBuffer.MatricesIndicesKind);
    loadAttribute("WEIGHTS_0", VertexBuffer.MatricesWeightsKind);
    loadAttribute("JOINTS_1", VertexBuffer.MatricesIndicesExtraKind);
    loadAttribute("WEIGHTS_1", VertexBuffer.MatricesWeightsExtraKind);
    loadAttribute("COLOR_0", VertexBuffer.ColorKind, (accessor) => {
      if (accessor.type === "VEC4") {
        babylonMesh.hasVertexAlpha = true;
      }
    });
    return Promise.all(promises).then(() => {
      return babylonGeometry;
    });
  }
  _createMorphTargets(context, node, mesh, primitive, babylonMesh) {
    if (!primitive.targets) {
      return;
    }
    if (node._numMorphTargets == void 0) {
      node._numMorphTargets = primitive.targets.length;
    } else if (primitive.targets.length !== node._numMorphTargets) {
      throw new Error(`${context}: Primitives do not have the same number of targets`);
    }
    const targetNames = mesh.extras ? mesh.extras.targetNames : null;
    babylonMesh.morphTargetManager = new MorphTargetManager(babylonMesh.getScene());
    babylonMesh.morphTargetManager.areUpdatesFrozen = true;
    for (let index = 0; index < primitive.targets.length; index++) {
      const weight = node.weights ? node.weights[index] : mesh.weights ? mesh.weights[index] : 0;
      const name = targetNames ? targetNames[index] : `morphTarget${index}`;
      babylonMesh.morphTargetManager.addTarget(new MorphTarget(name, weight, babylonMesh.getScene()));
    }
  }
  _loadMorphTargetsAsync(context, primitive, babylonMesh, babylonGeometry) {
    if (!primitive.targets) {
      return Promise.resolve();
    }
    const promises = new Array();
    const morphTargetManager = babylonMesh.morphTargetManager;
    for (let index = 0; index < morphTargetManager.numTargets; index++) {
      const babylonMorphTarget = morphTargetManager.getTarget(index);
      promises.push(this._loadMorphTargetVertexDataAsync(`${context}/targets/${index}`, babylonGeometry, primitive.targets[index], babylonMorphTarget));
    }
    return Promise.all(promises).then(() => {
      morphTargetManager.areUpdatesFrozen = false;
    });
  }
  _loadMorphTargetVertexDataAsync(context, babylonGeometry, attributes, babylonMorphTarget) {
    const promises = new Array();
    const loadAttribute = (attribute, kind, setData) => {
      if (attributes[attribute] == void 0) {
        return;
      }
      const babylonVertexBuffer = babylonGeometry.getVertexBuffer(kind);
      if (!babylonVertexBuffer) {
        return;
      }
      const accessor = ArrayItem.Get(`${context}/${attribute}`, this._gltf.accessors, attributes[attribute]);
      promises.push(this._loadFloatAccessorAsync(`/accessors/${accessor.index}`, accessor).then((data) => {
        setData(babylonVertexBuffer, data);
      }));
    };
    loadAttribute("POSITION", VertexBuffer.PositionKind, (babylonVertexBuffer, data) => {
      const positions = new Float32Array(data.length);
      babylonVertexBuffer.forEach(data.length, (value, index) => {
        positions[index] = data[index] + value;
      });
      babylonMorphTarget.setPositions(positions);
    });
    loadAttribute("NORMAL", VertexBuffer.NormalKind, (babylonVertexBuffer, data) => {
      const normals = new Float32Array(data.length);
      babylonVertexBuffer.forEach(normals.length, (value, index) => {
        normals[index] = data[index] + value;
      });
      babylonMorphTarget.setNormals(normals);
    });
    loadAttribute("TANGENT", VertexBuffer.TangentKind, (babylonVertexBuffer, data) => {
      const tangents = new Float32Array(data.length / 3 * 4);
      let dataIndex = 0;
      babylonVertexBuffer.forEach(data.length / 3 * 4, (value, index) => {
        if ((index + 1) % 4 !== 0) {
          tangents[dataIndex] = data[dataIndex] + value;
          dataIndex++;
        }
      });
      babylonMorphTarget.setTangents(tangents);
    });
    return Promise.all(promises).then(() => {
    });
  }
  static _LoadTransform(node, babylonNode) {
    if (node.skin != void 0) {
      return;
    }
    let position = Vector3.Zero();
    let rotation = Quaternion.Identity();
    let scaling = Vector3.One();
    if (node.matrix) {
      const matrix = Matrix.FromArray(node.matrix);
      matrix.decompose(scaling, rotation, position);
    } else {
      if (node.translation) {
        position = Vector3.FromArray(node.translation);
      }
      if (node.rotation) {
        rotation = Quaternion.FromArray(node.rotation);
      }
      if (node.scale) {
        scaling = Vector3.FromArray(node.scale);
      }
    }
    babylonNode.position = position;
    babylonNode.rotationQuaternion = rotation;
    babylonNode.scaling = scaling;
  }
  _loadSkinAsync(context, node, skin, assign) {
    const extensionPromise = this._extensionsLoadSkinAsync(context, node, skin);
    if (extensionPromise) {
      return extensionPromise;
    }
    if (skin._data) {
      assign(skin._data.babylonSkeleton);
      return skin._data.promise;
    }
    const skeletonId = `skeleton${skin.index}`;
    this._babylonScene._blockEntityCollection = !!this._assetContainer;
    const babylonSkeleton = new Skeleton(skin.name || skeletonId, skeletonId, this._babylonScene);
    babylonSkeleton._parentContainer = this._assetContainer;
    this._babylonScene._blockEntityCollection = false;
    this._loadBones(context, skin, babylonSkeleton);
    const promise = this._loadSkinInverseBindMatricesDataAsync(context, skin).then((inverseBindMatricesData) => {
      this._updateBoneMatrices(babylonSkeleton, inverseBindMatricesData);
    });
    skin._data = {
      babylonSkeleton,
      promise
    };
    assign(babylonSkeleton);
    return promise;
  }
  _loadBones(context, skin, babylonSkeleton) {
    if (skin.skeleton == void 0 || this._parent.alwaysComputeSkeletonRootNode) {
      const rootNode = this._findSkeletonRootNode(`${context}/joints`, skin.joints);
      if (rootNode) {
        if (skin.skeleton === void 0) {
          skin.skeleton = rootNode.index;
        } else {
          const isParent = (a, b) => {
            for (; b.parent; b = b.parent) {
              if (b.parent === a) {
                return true;
              }
            }
            return false;
          };
          const skeletonNode = ArrayItem.Get(`${context}/skeleton`, this._gltf.nodes, skin.skeleton);
          if (skeletonNode !== rootNode && !isParent(skeletonNode, rootNode)) {
            Logger.Warn(`${context}/skeleton: Overriding with nearest common ancestor as skeleton node is not a common root`);
            skin.skeleton = rootNode.index;
          }
        }
      } else {
        Logger.Warn(`${context}: Failed to find common root`);
      }
    }
    const babylonBones = {};
    for (const index of skin.joints) {
      const node = ArrayItem.Get(`${context}/joints/${index}`, this._gltf.nodes, index);
      this._loadBone(node, skin, babylonSkeleton, babylonBones);
    }
  }
  _findSkeletonRootNode(context, joints) {
    if (joints.length === 0) {
      return null;
    }
    const paths = {};
    for (const index of joints) {
      const path = new Array();
      let node = ArrayItem.Get(`${context}/${index}`, this._gltf.nodes, index);
      while (node.index !== -1) {
        path.unshift(node);
        node = node.parent;
      }
      paths[index] = path;
    }
    let rootNode = null;
    for (let i = 0; ; ++i) {
      let path = paths[joints[0]];
      if (i >= path.length) {
        return rootNode;
      }
      const node = path[i];
      for (let j = 1; j < joints.length; ++j) {
        path = paths[joints[j]];
        if (i >= path.length || node !== path[i]) {
          return rootNode;
        }
      }
      rootNode = node;
    }
  }
  _loadBone(node, skin, babylonSkeleton, babylonBones) {
    let babylonBone = babylonBones[node.index];
    if (babylonBone) {
      return babylonBone;
    }
    let parentBabylonBone = null;
    if (node.index !== skin.skeleton) {
      if (node.parent && node.parent.index !== -1) {
        parentBabylonBone = this._loadBone(node.parent, skin, babylonSkeleton, babylonBones);
      } else if (skin.skeleton !== void 0) {
        Logger.Warn(`/skins/${skin.index}/skeleton: Skeleton node is not a common root`);
      }
    }
    const boneIndex = skin.joints.indexOf(node.index);
    babylonBone = new Bone(node.name || `joint${node.index}`, babylonSkeleton, parentBabylonBone, this._getNodeMatrix(node), null, null, boneIndex);
    babylonBones[node.index] = babylonBone;
    this._postSceneLoadActions.push(() => {
      babylonBone.linkTransformNode(node._babylonTransformNode);
    });
    return babylonBone;
  }
  _loadSkinInverseBindMatricesDataAsync(context, skin) {
    if (skin.inverseBindMatrices == void 0) {
      return Promise.resolve(null);
    }
    const accessor = ArrayItem.Get(`${context}/inverseBindMatrices`, this._gltf.accessors, skin.inverseBindMatrices);
    return this._loadFloatAccessorAsync(`/accessors/${accessor.index}`, accessor);
  }
  _updateBoneMatrices(babylonSkeleton, inverseBindMatricesData) {
    for (const babylonBone of babylonSkeleton.bones) {
      const baseMatrix = Matrix.Identity();
      const boneIndex = babylonBone._index;
      if (inverseBindMatricesData && boneIndex !== -1) {
        Matrix.FromArrayToRef(inverseBindMatricesData, boneIndex * 16, baseMatrix);
        baseMatrix.invertToRef(baseMatrix);
      }
      const babylonParentBone = babylonBone.getParent();
      if (babylonParentBone) {
        baseMatrix.multiplyToRef(babylonParentBone.getInvertedAbsoluteTransform(), baseMatrix);
      }
      babylonBone.updateMatrix(baseMatrix, false, false);
      babylonBone._updateDifferenceMatrix(void 0, false);
    }
  }
  _getNodeMatrix(node) {
    return node.matrix ? Matrix.FromArray(node.matrix) : Matrix.Compose(node.scale ? Vector3.FromArray(node.scale) : Vector3.One(), node.rotation ? Quaternion.FromArray(node.rotation) : Quaternion.Identity(), node.translation ? Vector3.FromArray(node.translation) : Vector3.Zero());
  }
  loadCameraAsync(context, camera, assign = () => {
  }) {
    const extensionPromise = this._extensionsLoadCameraAsync(context, camera, assign);
    if (extensionPromise) {
      return extensionPromise;
    }
    const promises = new Array();
    this.logOpen(`${context} ${camera.name || ""}`);
    this._babylonScene._blockEntityCollection = !!this._assetContainer;
    const babylonCamera = new FreeCamera(camera.name || `camera${camera.index}`, Vector3.Zero(), this._babylonScene, false);
    babylonCamera._parentContainer = this._assetContainer;
    this._babylonScene._blockEntityCollection = false;
    babylonCamera.ignoreParentScaling = true;
    camera._babylonCamera = babylonCamera;
    babylonCamera.rotation = new Vector3(0, Math.PI, 0);
    switch (camera.type) {
      case "perspective": {
        const perspective = camera.perspective;
        if (!perspective) {
          throw new Error(`${context}: Camera perspective properties are missing`);
        }
        babylonCamera.fov = perspective.yfov;
        babylonCamera.minZ = perspective.znear;
        babylonCamera.maxZ = perspective.zfar || 0;
        break;
      }
      case "orthographic": {
        if (!camera.orthographic) {
          throw new Error(`${context}: Camera orthographic properties are missing`);
        }
        babylonCamera.mode = Camera.ORTHOGRAPHIC_CAMERA;
        babylonCamera.orthoLeft = -camera.orthographic.xmag;
        babylonCamera.orthoRight = camera.orthographic.xmag;
        babylonCamera.orthoBottom = -camera.orthographic.ymag;
        babylonCamera.orthoTop = camera.orthographic.ymag;
        babylonCamera.minZ = camera.orthographic.znear;
        babylonCamera.maxZ = camera.orthographic.zfar;
        break;
      }
      default: {
        throw new Error(`${context}: Invalid camera type (${camera.type})`);
      }
    }
    GLTFLoader2.AddPointerMetadata(babylonCamera, context);
    this._parent.onCameraLoadedObservable.notifyObservers(babylonCamera);
    assign(babylonCamera);
    this.logClose();
    return Promise.all(promises).then(() => {
      return babylonCamera;
    });
  }
  _loadAnimationsAsync() {
    const animations = this._gltf.animations;
    if (!animations) {
      return Promise.resolve();
    }
    const promises = new Array();
    for (let index = 0; index < animations.length; index++) {
      const animation = animations[index];
      promises.push(this.loadAnimationAsync(`/animations/${animation.index}`, animation).then((animationGroup) => {
        if (animationGroup.targetedAnimations.length === 0) {
          animationGroup.dispose();
        }
      }));
    }
    return Promise.all(promises).then(() => {
    });
  }
  loadAnimationAsync(context, animation) {
    const promise = this._extensionsLoadAnimationAsync(context, animation);
    if (promise) {
      return promise;
    }
    this._babylonScene._blockEntityCollection = !!this._assetContainer;
    const babylonAnimationGroup = new AnimationGroup(animation.name || `animation${animation.index}`, this._babylonScene);
    babylonAnimationGroup._parentContainer = this._assetContainer;
    this._babylonScene._blockEntityCollection = false;
    animation._babylonAnimationGroup = babylonAnimationGroup;
    const promises = new Array();
    ArrayItem.Assign(animation.channels);
    ArrayItem.Assign(animation.samplers);
    for (const channel of animation.channels) {
      promises.push(this._loadAnimationChannelAsync(`${context}/channels/${channel.index}`, context, animation, channel, (babylonTarget, babylonAnimation) => {
        babylonTarget.animations = babylonTarget.animations || [];
        babylonTarget.animations.push(babylonAnimation);
        babylonAnimationGroup.addTargetedAnimation(babylonAnimation, babylonTarget);
      }));
    }
    return Promise.all(promises).then(() => {
      babylonAnimationGroup.normalize(0);
      return babylonAnimationGroup;
    });
  }
  _loadAnimationChannelAsync(context, animationContext, animation, channel, onLoad) {
    const promise = this._extensionsLoadAnimationChannelAsync(context, animationContext, animation, channel, onLoad);
    if (promise) {
      return promise;
    }
    if (channel.target.node == void 0) {
      return Promise.resolve();
    }
    const targetNode = ArrayItem.Get(`${context}/target/node`, this._gltf.nodes, channel.target.node);
    if (channel.target.path === "weights" && !targetNode._numMorphTargets || channel.target.path !== "weights" && !targetNode._babylonTransformNode) {
      return Promise.resolve();
    }
    let properties;
    switch (channel.target.path) {
      case "translation": {
        properties = nodeAnimationData.translation;
        break;
      }
      case "rotation": {
        properties = nodeAnimationData.rotation;
        break;
      }
      case "scale": {
        properties = nodeAnimationData.scale;
        break;
      }
      case "weights": {
        properties = nodeAnimationData.weights;
        break;
      }
      default: {
        throw new Error(`${context}/target/path: Invalid value (${channel.target.path})`);
      }
    }
    const targetInfo = {
      target: targetNode,
      properties
    };
    return this._loadAnimationChannelFromTargetInfoAsync(context, animationContext, animation, channel, targetInfo, onLoad);
  }
  _loadAnimationChannelFromTargetInfoAsync(context, animationContext, animation, channel, targetInfo, onLoad) {
    const fps = this.parent.targetFps;
    const invfps = 1 / fps;
    const sampler = ArrayItem.Get(`${context}/sampler`, animation.samplers, channel.sampler);
    return this._loadAnimationSamplerAsync(`${animationContext}/samplers/${channel.sampler}`, sampler).then((data) => {
      let numAnimations = 0;
      for (const property of targetInfo.properties) {
        const stride = property.getStride(targetInfo.target);
        const input = data.input;
        const output = data.output;
        const keys = new Array(input.length);
        let outputOffset = 0;
        switch (data.interpolation) {
          case "STEP": {
            for (let index = 0; index < input.length; index++) {
              const value = property.getValue(targetInfo.target, output, outputOffset, 1);
              outputOffset += stride;
              keys[index] = {
                frame: input[index] * fps,
                value,
                interpolation: AnimationKeyInterpolation.STEP
              };
            }
            break;
          }
          case "CUBICSPLINE": {
            for (let index = 0; index < input.length; index++) {
              const inTangent = property.getValue(targetInfo.target, output, outputOffset, invfps);
              outputOffset += stride;
              const value = property.getValue(targetInfo.target, output, outputOffset, 1);
              outputOffset += stride;
              const outTangent = property.getValue(targetInfo.target, output, outputOffset, invfps);
              outputOffset += stride;
              keys[index] = {
                frame: input[index] * fps,
                inTangent,
                value,
                outTangent
              };
            }
            break;
          }
          case "LINEAR": {
            for (let index = 0; index < input.length; index++) {
              const value = property.getValue(targetInfo.target, output, outputOffset, 1);
              outputOffset += stride;
              keys[index] = {
                frame: input[index] * fps,
                value
              };
            }
            break;
          }
        }
        if (outputOffset > 0) {
          const name = `${animation.name || `animation${animation.index}`}_channel${channel.index}_${numAnimations}`;
          property.buildAnimations(targetInfo.target, name, fps, keys, (babylonAnimatable, babylonAnimation) => {
            ++numAnimations;
            onLoad(babylonAnimatable, babylonAnimation);
          });
        }
      }
    });
  }
  _loadAnimationSamplerAsync(context, sampler) {
    if (sampler._data) {
      return sampler._data;
    }
    const interpolation = sampler.interpolation || "LINEAR";
    switch (interpolation) {
      case "STEP":
      case "LINEAR":
      case "CUBICSPLINE": {
        break;
      }
      default: {
        throw new Error(`${context}/interpolation: Invalid value (${sampler.interpolation})`);
      }
    }
    const inputAccessor = ArrayItem.Get(`${context}/input`, this._gltf.accessors, sampler.input);
    const outputAccessor = ArrayItem.Get(`${context}/output`, this._gltf.accessors, sampler.output);
    sampler._data = Promise.all([
      this._loadFloatAccessorAsync(`/accessors/${inputAccessor.index}`, inputAccessor),
      this._loadFloatAccessorAsync(`/accessors/${outputAccessor.index}`, outputAccessor)
    ]).then(([inputData, outputData]) => {
      return {
        input: inputData,
        interpolation,
        output: outputData
      };
    });
    return sampler._data;
  }
  loadBufferAsync(context, buffer, byteOffset, byteLength) {
    const extensionPromise = this._extensionsLoadBufferAsync(context, buffer, byteOffset, byteLength);
    if (extensionPromise) {
      return extensionPromise;
    }
    if (!buffer._data) {
      if (buffer.uri) {
        buffer._data = this.loadUriAsync(`${context}/uri`, buffer, buffer.uri);
      } else {
        if (!this._bin) {
          throw new Error(`${context}: Uri is missing or the binary glTF is missing its binary chunk`);
        }
        buffer._data = this._bin.readAsync(0, buffer.byteLength);
      }
    }
    return buffer._data.then((data) => {
      try {
        return new Uint8Array(data.buffer, data.byteOffset + byteOffset, byteLength);
      } catch (e) {
        throw new Error(`${context}: ${e.message}`);
      }
    });
  }
  loadBufferViewAsync(context, bufferView) {
    const extensionPromise = this._extensionsLoadBufferViewAsync(context, bufferView);
    if (extensionPromise) {
      return extensionPromise;
    }
    if (bufferView._data) {
      return bufferView._data;
    }
    const buffer = ArrayItem.Get(`${context}/buffer`, this._gltf.buffers, bufferView.buffer);
    bufferView._data = this.loadBufferAsync(`/buffers/${buffer.index}`, buffer, bufferView.byteOffset || 0, bufferView.byteLength);
    return bufferView._data;
  }
  _loadAccessorAsync(context, accessor, constructor) {
    if (accessor._data) {
      return accessor._data;
    }
    const numComponents = GLTFLoader2._GetNumComponents(context, accessor.type);
    const byteStride = numComponents * VertexBuffer.GetTypeByteLength(accessor.componentType);
    const length = numComponents * accessor.count;
    if (accessor.bufferView == void 0) {
      accessor._data = Promise.resolve(new constructor(length));
    } else {
      const bufferView = ArrayItem.Get(`${context}/bufferView`, this._gltf.bufferViews, accessor.bufferView);
      accessor._data = this.loadBufferViewAsync(`/bufferViews/${bufferView.index}`, bufferView).then((data) => {
        if (accessor.componentType === 5126 && !accessor.normalized && (!bufferView.byteStride || bufferView.byteStride === byteStride)) {
          return GLTFLoader2._GetTypedArray(context, accessor.componentType, data, accessor.byteOffset, length);
        } else {
          const typedArray = new constructor(length);
          VertexBuffer.ForEach(data, accessor.byteOffset || 0, bufferView.byteStride || byteStride, numComponents, accessor.componentType, typedArray.length, accessor.normalized || false, (value, index) => {
            typedArray[index] = value;
          });
          return typedArray;
        }
      });
    }
    if (accessor.sparse) {
      const sparse = accessor.sparse;
      accessor._data = accessor._data.then((data) => {
        const typedArray = data;
        const indicesBufferView = ArrayItem.Get(`${context}/sparse/indices/bufferView`, this._gltf.bufferViews, sparse.indices.bufferView);
        const valuesBufferView = ArrayItem.Get(`${context}/sparse/values/bufferView`, this._gltf.bufferViews, sparse.values.bufferView);
        return Promise.all([
          this.loadBufferViewAsync(`/bufferViews/${indicesBufferView.index}`, indicesBufferView),
          this.loadBufferViewAsync(`/bufferViews/${valuesBufferView.index}`, valuesBufferView)
        ]).then(([indicesData, valuesData]) => {
          const indices = GLTFLoader2._GetTypedArray(`${context}/sparse/indices`, sparse.indices.componentType, indicesData, sparse.indices.byteOffset, sparse.count);
          const sparseLength = numComponents * sparse.count;
          let values;
          if (accessor.componentType === 5126 && !accessor.normalized) {
            values = GLTFLoader2._GetTypedArray(`${context}/sparse/values`, accessor.componentType, valuesData, sparse.values.byteOffset, sparseLength);
          } else {
            const sparseData = GLTFLoader2._GetTypedArray(`${context}/sparse/values`, accessor.componentType, valuesData, sparse.values.byteOffset, sparseLength);
            values = new constructor(sparseLength);
            VertexBuffer.ForEach(sparseData, 0, byteStride, numComponents, accessor.componentType, values.length, accessor.normalized || false, (value, index) => {
              values[index] = value;
            });
          }
          let valuesIndex = 0;
          for (let indicesIndex = 0; indicesIndex < indices.length; indicesIndex++) {
            let dataIndex = indices[indicesIndex] * numComponents;
            for (let componentIndex = 0; componentIndex < numComponents; componentIndex++) {
              typedArray[dataIndex++] = values[valuesIndex++];
            }
          }
          return typedArray;
        });
      });
    }
    return accessor._data;
  }
  _loadFloatAccessorAsync(context, accessor) {
    return this._loadAccessorAsync(context, accessor, Float32Array);
  }
  _loadIndicesAccessorAsync(context, accessor) {
    if (accessor.type !== "SCALAR") {
      throw new Error(`${context}/type: Invalid value ${accessor.type}`);
    }
    if (accessor.componentType !== 5121 && accessor.componentType !== 5123 && accessor.componentType !== 5125) {
      throw new Error(`${context}/componentType: Invalid value ${accessor.componentType}`);
    }
    if (accessor._data) {
      return accessor._data;
    }
    if (accessor.sparse) {
      const constructor = GLTFLoader2._GetTypedArrayConstructor(`${context}/componentType`, accessor.componentType);
      accessor._data = this._loadAccessorAsync(context, accessor, constructor);
    } else {
      const bufferView = ArrayItem.Get(`${context}/bufferView`, this._gltf.bufferViews, accessor.bufferView);
      accessor._data = this.loadBufferViewAsync(`/bufferViews/${bufferView.index}`, bufferView).then((data) => {
        return GLTFLoader2._GetTypedArray(context, accessor.componentType, data, accessor.byteOffset, accessor.count);
      });
    }
    return accessor._data;
  }
  _loadVertexBufferViewAsync(bufferView) {
    if (bufferView._babylonBuffer) {
      return bufferView._babylonBuffer;
    }
    const engine = this._babylonScene.getEngine();
    bufferView._babylonBuffer = this.loadBufferViewAsync(`/bufferViews/${bufferView.index}`, bufferView).then((data) => {
      return new Buffer(engine, data, false);
    });
    return bufferView._babylonBuffer;
  }
  _loadVertexAccessorAsync(context, accessor, kind) {
    var _a;
    if ((_a = accessor._babylonVertexBuffer) === null || _a === void 0 ? void 0 : _a[kind]) {
      return accessor._babylonVertexBuffer[kind];
    }
    if (!accessor._babylonVertexBuffer) {
      accessor._babylonVertexBuffer = {};
    }
    const engine = this._babylonScene.getEngine();
    if (accessor.sparse) {
      accessor._babylonVertexBuffer[kind] = this._loadFloatAccessorAsync(context, accessor).then((data) => {
        return new VertexBuffer(engine, data, kind, false);
      });
    } else if (kind === VertexBuffer.MatricesIndicesKind || kind === VertexBuffer.MatricesIndicesExtraKind) {
      accessor._babylonVertexBuffer[kind] = this._loadFloatAccessorAsync(context, accessor).then((data) => {
        return new VertexBuffer(engine, data, kind, false);
      });
    } else {
      const bufferView = ArrayItem.Get(`${context}/bufferView`, this._gltf.bufferViews, accessor.bufferView);
      accessor._babylonVertexBuffer[kind] = this._loadVertexBufferViewAsync(bufferView).then((babylonBuffer) => {
        const size = GLTFLoader2._GetNumComponents(context, accessor.type);
        return new VertexBuffer(engine, babylonBuffer, kind, false, false, bufferView.byteStride, false, accessor.byteOffset, size, accessor.componentType, accessor.normalized, true, 1, true);
      });
    }
    return accessor._babylonVertexBuffer[kind];
  }
  _loadMaterialMetallicRoughnessPropertiesAsync(context, properties, babylonMaterial) {
    if (!(babylonMaterial instanceof PBRMaterial)) {
      throw new Error(`${context}: Material type not supported`);
    }
    const promises = new Array();
    if (properties) {
      if (properties.baseColorFactor) {
        babylonMaterial.albedoColor = Color3.FromArray(properties.baseColorFactor);
        babylonMaterial.alpha = properties.baseColorFactor[3];
      } else {
        babylonMaterial.albedoColor = Color3.White();
      }
      babylonMaterial.metallic = properties.metallicFactor == void 0 ? 1 : properties.metallicFactor;
      babylonMaterial.roughness = properties.roughnessFactor == void 0 ? 1 : properties.roughnessFactor;
      if (properties.baseColorTexture) {
        promises.push(this.loadTextureInfoAsync(`${context}/baseColorTexture`, properties.baseColorTexture, (texture) => {
          texture.name = `${babylonMaterial.name} (Base Color)`;
          babylonMaterial.albedoTexture = texture;
        }));
      }
      if (properties.metallicRoughnessTexture) {
        properties.metallicRoughnessTexture.nonColorData = true;
        promises.push(this.loadTextureInfoAsync(`${context}/metallicRoughnessTexture`, properties.metallicRoughnessTexture, (texture) => {
          texture.name = `${babylonMaterial.name} (Metallic Roughness)`;
          babylonMaterial.metallicTexture = texture;
        }));
        babylonMaterial.useMetallnessFromMetallicTextureBlue = true;
        babylonMaterial.useRoughnessFromMetallicTextureGreen = true;
        babylonMaterial.useRoughnessFromMetallicTextureAlpha = false;
      }
    }
    return Promise.all(promises).then(() => {
    });
  }
  _loadMaterialAsync(context, material, babylonMesh, babylonDrawMode, assign = () => {
  }) {
    const extensionPromise = this._extensionsLoadMaterialAsync(context, material, babylonMesh, babylonDrawMode, assign);
    if (extensionPromise) {
      return extensionPromise;
    }
    material._data = material._data || {};
    let babylonData = material._data[babylonDrawMode];
    if (!babylonData) {
      this.logOpen(`${context} ${material.name || ""}`);
      const babylonMaterial = this.createMaterial(context, material, babylonDrawMode);
      babylonData = {
        babylonMaterial,
        babylonMeshes: [],
        promise: this.loadMaterialPropertiesAsync(context, material, babylonMaterial)
      };
      material._data[babylonDrawMode] = babylonData;
      GLTFLoader2.AddPointerMetadata(babylonMaterial, context);
      this._parent.onMaterialLoadedObservable.notifyObservers(babylonMaterial);
      this.logClose();
    }
    if (babylonMesh) {
      babylonData.babylonMeshes.push(babylonMesh);
      babylonMesh.onDisposeObservable.addOnce(() => {
        const index = babylonData.babylonMeshes.indexOf(babylonMesh);
        if (index !== -1) {
          babylonData.babylonMeshes.splice(index, 1);
        }
      });
    }
    assign(babylonData.babylonMaterial);
    return babylonData.promise.then(() => {
      return babylonData.babylonMaterial;
    });
  }
  _createDefaultMaterial(name, babylonDrawMode) {
    this._babylonScene._blockEntityCollection = !!this._assetContainer;
    const babylonMaterial = new PBRMaterial(name, this._babylonScene);
    babylonMaterial._parentContainer = this._assetContainer;
    this._babylonScene._blockEntityCollection = false;
    babylonMaterial.fillMode = babylonDrawMode;
    babylonMaterial.enableSpecularAntiAliasing = true;
    babylonMaterial.useRadianceOverAlpha = !this._parent.transparencyAsCoverage;
    babylonMaterial.useSpecularOverAlpha = !this._parent.transparencyAsCoverage;
    babylonMaterial.transparencyMode = PBRMaterial.PBRMATERIAL_OPAQUE;
    babylonMaterial.metallic = 1;
    babylonMaterial.roughness = 1;
    return babylonMaterial;
  }
  createMaterial(context, material, babylonDrawMode) {
    const extensionPromise = this._extensionsCreateMaterial(context, material, babylonDrawMode);
    if (extensionPromise) {
      return extensionPromise;
    }
    const name = material.name || `material${material.index}`;
    const babylonMaterial = this._createDefaultMaterial(name, babylonDrawMode);
    return babylonMaterial;
  }
  loadMaterialPropertiesAsync(context, material, babylonMaterial) {
    const extensionPromise = this._extensionsLoadMaterialPropertiesAsync(context, material, babylonMaterial);
    if (extensionPromise) {
      return extensionPromise;
    }
    const promises = new Array();
    promises.push(this.loadMaterialBasePropertiesAsync(context, material, babylonMaterial));
    if (material.pbrMetallicRoughness) {
      promises.push(this._loadMaterialMetallicRoughnessPropertiesAsync(`${context}/pbrMetallicRoughness`, material.pbrMetallicRoughness, babylonMaterial));
    }
    this.loadMaterialAlphaProperties(context, material, babylonMaterial);
    return Promise.all(promises).then(() => {
    });
  }
  loadMaterialBasePropertiesAsync(context, material, babylonMaterial) {
    if (!(babylonMaterial instanceof PBRMaterial)) {
      throw new Error(`${context}: Material type not supported`);
    }
    const promises = new Array();
    babylonMaterial.emissiveColor = material.emissiveFactor ? Color3.FromArray(material.emissiveFactor) : new Color3(0, 0, 0);
    if (material.doubleSided) {
      babylonMaterial.backFaceCulling = false;
      babylonMaterial.twoSidedLighting = true;
    }
    if (material.normalTexture) {
      material.normalTexture.nonColorData = true;
      promises.push(this.loadTextureInfoAsync(`${context}/normalTexture`, material.normalTexture, (texture) => {
        texture.name = `${babylonMaterial.name} (Normal)`;
        babylonMaterial.bumpTexture = texture;
      }));
      babylonMaterial.invertNormalMapX = !this._babylonScene.useRightHandedSystem;
      babylonMaterial.invertNormalMapY = this._babylonScene.useRightHandedSystem;
      if (material.normalTexture.scale != void 0 && babylonMaterial.bumpTexture) {
        babylonMaterial.bumpTexture.level = material.normalTexture.scale;
      }
      babylonMaterial.forceIrradianceInFragment = true;
    }
    if (material.occlusionTexture) {
      material.occlusionTexture.nonColorData = true;
      promises.push(this.loadTextureInfoAsync(`${context}/occlusionTexture`, material.occlusionTexture, (texture) => {
        texture.name = `${babylonMaterial.name} (Occlusion)`;
        babylonMaterial.ambientTexture = texture;
      }));
      babylonMaterial.useAmbientInGrayScale = true;
      if (material.occlusionTexture.strength != void 0) {
        babylonMaterial.ambientTextureStrength = material.occlusionTexture.strength;
      }
    }
    if (material.emissiveTexture) {
      promises.push(this.loadTextureInfoAsync(`${context}/emissiveTexture`, material.emissiveTexture, (texture) => {
        texture.name = `${babylonMaterial.name} (Emissive)`;
        babylonMaterial.emissiveTexture = texture;
      }));
    }
    return Promise.all(promises).then(() => {
    });
  }
  loadMaterialAlphaProperties(context, material, babylonMaterial) {
    if (!(babylonMaterial instanceof PBRMaterial)) {
      throw new Error(`${context}: Material type not supported`);
    }
    const alphaMode = material.alphaMode || "OPAQUE";
    switch (alphaMode) {
      case "OPAQUE": {
        babylonMaterial.transparencyMode = PBRMaterial.PBRMATERIAL_OPAQUE;
        break;
      }
      case "MASK": {
        babylonMaterial.transparencyMode = PBRMaterial.PBRMATERIAL_ALPHATEST;
        babylonMaterial.alphaCutOff = material.alphaCutoff == void 0 ? 0.5 : material.alphaCutoff;
        if (babylonMaterial.albedoTexture) {
          babylonMaterial.albedoTexture.hasAlpha = true;
        }
        break;
      }
      case "BLEND": {
        babylonMaterial.transparencyMode = PBRMaterial.PBRMATERIAL_ALPHABLEND;
        if (babylonMaterial.albedoTexture) {
          babylonMaterial.albedoTexture.hasAlpha = true;
          babylonMaterial.useAlphaFromAlbedoTexture = true;
        }
        break;
      }
      default: {
        throw new Error(`${context}/alphaMode: Invalid value (${material.alphaMode})`);
      }
    }
  }
  loadTextureInfoAsync(context, textureInfo, assign = () => {
  }) {
    const extensionPromise = this._extensionsLoadTextureInfoAsync(context, textureInfo, assign);
    if (extensionPromise) {
      return extensionPromise;
    }
    this.logOpen(`${context}`);
    if (textureInfo.texCoord >= 6) {
      throw new Error(`${context}/texCoord: Invalid value (${textureInfo.texCoord})`);
    }
    const texture = ArrayItem.Get(`${context}/index`, this._gltf.textures, textureInfo.index);
    texture._textureInfo = textureInfo;
    const promise = this._loadTextureAsync(`/textures/${textureInfo.index}`, texture, (babylonTexture) => {
      babylonTexture.coordinatesIndex = textureInfo.texCoord || 0;
      GLTFLoader2.AddPointerMetadata(babylonTexture, context);
      this._parent.onTextureLoadedObservable.notifyObservers(babylonTexture);
      assign(babylonTexture);
    });
    this.logClose();
    return promise;
  }
  _loadTextureAsync(context, texture, assign = () => {
  }) {
    const extensionPromise = this._extensionsLoadTextureAsync(context, texture, assign);
    if (extensionPromise) {
      return extensionPromise;
    }
    this.logOpen(`${context} ${texture.name || ""}`);
    const sampler = texture.sampler == void 0 ? GLTFLoader2.DefaultSampler : ArrayItem.Get(`${context}/sampler`, this._gltf.samplers, texture.sampler);
    const image = ArrayItem.Get(`${context}/source`, this._gltf.images, texture.source);
    const promise = this._createTextureAsync(context, sampler, image, assign, void 0, !texture._textureInfo.nonColorData);
    this.logClose();
    return promise;
  }
  _createTextureAsync(context, sampler, image, assign = () => {
  }, textureLoaderOptions, useSRGBBuffer) {
    const samplerData = this._loadSampler(`/samplers/${sampler.index}`, sampler);
    const promises = new Array();
    const deferred = new Deferred();
    this._babylonScene._blockEntityCollection = !!this._assetContainer;
    const textureCreationOptions = {
      noMipmap: samplerData.noMipMaps,
      invertY: false,
      samplingMode: samplerData.samplingMode,
      onLoad: () => {
        if (!this._disposed) {
          deferred.resolve();
        }
      },
      onError: (message, exception) => {
        if (!this._disposed) {
          deferred.reject(new Error(`${context}: ${exception && exception.message ? exception.message : message || "Failed to load texture"}`));
        }
      },
      mimeType: image.mimeType,
      loaderOptions: textureLoaderOptions,
      useSRGBBuffer: !!useSRGBBuffer && this._parent.useSRGBBuffers
    };
    const babylonTexture = new Texture(null, this._babylonScene, textureCreationOptions);
    babylonTexture._parentContainer = this._assetContainer;
    this._babylonScene._blockEntityCollection = false;
    promises.push(deferred.promise);
    promises.push(this.loadImageAsync(`/images/${image.index}`, image).then((data) => {
      const name = image.uri || `${this._fileName}#image${image.index}`;
      const dataUrl = `data:${this._uniqueRootUrl}${name}`;
      babylonTexture.updateURL(dataUrl, data);
    }));
    babylonTexture.wrapU = samplerData.wrapU;
    babylonTexture.wrapV = samplerData.wrapV;
    assign(babylonTexture);
    return Promise.all(promises).then(() => {
      return babylonTexture;
    });
  }
  _loadSampler(context, sampler) {
    if (!sampler._data) {
      sampler._data = {
        noMipMaps: sampler.minFilter === 9728 || sampler.minFilter === 9729,
        samplingMode: GLTFLoader2._GetTextureSamplingMode(context, sampler),
        wrapU: GLTFLoader2._GetTextureWrapMode(`${context}/wrapS`, sampler.wrapS),
        wrapV: GLTFLoader2._GetTextureWrapMode(`${context}/wrapT`, sampler.wrapT)
      };
    }
    return sampler._data;
  }
  loadImageAsync(context, image) {
    if (!image._data) {
      this.logOpen(`${context} ${image.name || ""}`);
      if (image.uri) {
        image._data = this.loadUriAsync(`${context}/uri`, image, image.uri);
      } else {
        const bufferView = ArrayItem.Get(`${context}/bufferView`, this._gltf.bufferViews, image.bufferView);
        image._data = this.loadBufferViewAsync(`/bufferViews/${bufferView.index}`, bufferView);
      }
      this.logClose();
    }
    return image._data;
  }
  loadUriAsync(context, property, uri) {
    const extensionPromise = this._extensionsLoadUriAsync(context, property, uri);
    if (extensionPromise) {
      return extensionPromise;
    }
    if (!GLTFLoader2._ValidateUri(uri)) {
      throw new Error(`${context}: '${uri}' is invalid`);
    }
    if (IsBase64DataUrl(uri)) {
      const data = new Uint8Array(DecodeBase64UrlToBinary(uri));
      this.log(`${context}: Decoded ${uri.substr(0, 64)}... (${data.length} bytes)`);
      return Promise.resolve(data);
    }
    this.log(`${context}: Loading ${uri}`);
    return this._parent.preprocessUrlAsync(this._rootUrl + uri).then((url) => {
      return new Promise((resolve, reject) => {
        this._parent._loadFile(this._babylonScene, url, (data) => {
          if (!this._disposed) {
            this.log(`${context}: Loaded ${uri} (${data.byteLength} bytes)`);
            resolve(new Uint8Array(data));
          }
        }, true, (request) => {
          reject(new LoadFileError(`${context}: Failed to load '${uri}'${request ? ": " + request.status + " " + request.statusText : ""}`, request));
        });
      });
    });
  }
  static AddPointerMetadata(babylonObject, pointer) {
    const metadata = babylonObject.metadata = babylonObject.metadata || {};
    const gltf = metadata.gltf = metadata.gltf || {};
    const pointers = gltf.pointers = gltf.pointers || [];
    pointers.push(pointer);
  }
  static _GetTextureWrapMode(context, mode) {
    mode = mode == void 0 ? 10497 : mode;
    switch (mode) {
      case 33071:
        return Texture.CLAMP_ADDRESSMODE;
      case 33648:
        return Texture.MIRROR_ADDRESSMODE;
      case 10497:
        return Texture.WRAP_ADDRESSMODE;
      default:
        Logger.Warn(`${context}: Invalid value (${mode})`);
        return Texture.WRAP_ADDRESSMODE;
    }
  }
  static _GetTextureSamplingMode(context, sampler) {
    const magFilter = sampler.magFilter == void 0 ? 9729 : sampler.magFilter;
    const minFilter = sampler.minFilter == void 0 ? 9987 : sampler.minFilter;
    if (magFilter === 9729) {
      switch (minFilter) {
        case 9728:
          return Texture.LINEAR_NEAREST;
        case 9729:
          return Texture.LINEAR_LINEAR;
        case 9984:
          return Texture.LINEAR_NEAREST_MIPNEAREST;
        case 9985:
          return Texture.LINEAR_LINEAR_MIPNEAREST;
        case 9986:
          return Texture.LINEAR_NEAREST_MIPLINEAR;
        case 9987:
          return Texture.LINEAR_LINEAR_MIPLINEAR;
        default:
          Logger.Warn(`${context}/minFilter: Invalid value (${minFilter})`);
          return Texture.LINEAR_LINEAR_MIPLINEAR;
      }
    } else {
      if (magFilter !== 9728) {
        Logger.Warn(`${context}/magFilter: Invalid value (${magFilter})`);
      }
      switch (minFilter) {
        case 9728:
          return Texture.NEAREST_NEAREST;
        case 9729:
          return Texture.NEAREST_LINEAR;
        case 9984:
          return Texture.NEAREST_NEAREST_MIPNEAREST;
        case 9985:
          return Texture.NEAREST_LINEAR_MIPNEAREST;
        case 9986:
          return Texture.NEAREST_NEAREST_MIPLINEAR;
        case 9987:
          return Texture.NEAREST_LINEAR_MIPLINEAR;
        default:
          Logger.Warn(`${context}/minFilter: Invalid value (${minFilter})`);
          return Texture.NEAREST_NEAREST_MIPNEAREST;
      }
    }
  }
  static _GetTypedArrayConstructor(context, componentType) {
    switch (componentType) {
      case 5120:
        return Int8Array;
      case 5121:
        return Uint8Array;
      case 5122:
        return Int16Array;
      case 5123:
        return Uint16Array;
      case 5125:
        return Uint32Array;
      case 5126:
        return Float32Array;
      default:
        throw new Error(`${context}: Invalid component type ${componentType}`);
    }
  }
  static _GetTypedArray(context, componentType, bufferView, byteOffset, length) {
    const buffer = bufferView.buffer;
    byteOffset = bufferView.byteOffset + (byteOffset || 0);
    const constructor = GLTFLoader2._GetTypedArrayConstructor(`${context}/componentType`, componentType);
    const componentTypeLength = VertexBuffer.GetTypeByteLength(componentType);
    if (byteOffset % componentTypeLength !== 0) {
      Logger.Warn(`${context}: Copying buffer as byte offset (${byteOffset}) is not a multiple of component type byte length (${componentTypeLength})`);
      return new constructor(buffer.slice(byteOffset, byteOffset + length * componentTypeLength), 0);
    }
    return new constructor(buffer, byteOffset, length);
  }
  static _GetNumComponents(context, type) {
    switch (type) {
      case "SCALAR":
        return 1;
      case "VEC2":
        return 2;
      case "VEC3":
        return 3;
      case "VEC4":
        return 4;
      case "MAT2":
        return 4;
      case "MAT3":
        return 9;
      case "MAT4":
        return 16;
    }
    throw new Error(`${context}: Invalid type (${type})`);
  }
  static _ValidateUri(uri) {
    return Tools.IsBase64(uri) || uri.indexOf("..") === -1;
  }
  static _GetDrawMode(context, mode) {
    if (mode == void 0) {
      mode = 4;
    }
    switch (mode) {
      case 0:
        return Material.PointListDrawMode;
      case 1:
        return Material.LineListDrawMode;
      case 2:
        return Material.LineLoopDrawMode;
      case 3:
        return Material.LineStripDrawMode;
      case 4:
        return Material.TriangleFillMode;
      case 5:
        return Material.TriangleStripDrawMode;
      case 6:
        return Material.TriangleFanDrawMode;
    }
    throw new Error(`${context}: Invalid mesh primitive mode (${mode})`);
  }
  _compileMaterialsAsync() {
    this._parent._startPerformanceCounter("Compile materials");
    const promises = new Array();
    if (this._gltf.materials) {
      for (const material of this._gltf.materials) {
        if (material._data) {
          for (const babylonDrawMode in material._data) {
            const babylonData = material._data[babylonDrawMode];
            for (const babylonMesh of babylonData.babylonMeshes) {
              babylonMesh.computeWorldMatrix(true);
              const babylonMaterial = babylonData.babylonMaterial;
              promises.push(babylonMaterial.forceCompilationAsync(babylonMesh));
              promises.push(babylonMaterial.forceCompilationAsync(babylonMesh, { useInstances: true }));
              if (this._parent.useClipPlane) {
                promises.push(babylonMaterial.forceCompilationAsync(babylonMesh, { clipPlane: true }));
                promises.push(babylonMaterial.forceCompilationAsync(babylonMesh, { clipPlane: true, useInstances: true }));
              }
            }
          }
        }
      }
    }
    return Promise.all(promises).then(() => {
      this._parent._endPerformanceCounter("Compile materials");
    });
  }
  _compileShadowGeneratorsAsync() {
    this._parent._startPerformanceCounter("Compile shadow generators");
    const promises = new Array();
    const lights = this._babylonScene.lights;
    for (const light of lights) {
      const generator = light.getShadowGenerator();
      if (generator) {
        promises.push(generator.forceCompilationAsync());
      }
    }
    return Promise.all(promises).then(() => {
      this._parent._endPerformanceCounter("Compile shadow generators");
    });
  }
  _forEachExtensions(action) {
    for (const extension of this._extensions) {
      if (extension.enabled) {
        action(extension);
      }
    }
  }
  _applyExtensions(property, functionName, actionAsync) {
    for (const extension of this._extensions) {
      if (extension.enabled) {
        const id = `${extension.name}.${functionName}`;
        const loaderProperty = property;
        loaderProperty._activeLoaderExtensionFunctions = loaderProperty._activeLoaderExtensionFunctions || {};
        const activeLoaderExtensionFunctions = loaderProperty._activeLoaderExtensionFunctions;
        if (!activeLoaderExtensionFunctions[id]) {
          activeLoaderExtensionFunctions[id] = true;
          try {
            const result = actionAsync(extension);
            if (result) {
              return result;
            }
          } finally {
            delete activeLoaderExtensionFunctions[id];
          }
        }
      }
    }
    return null;
  }
  _extensionsOnLoading() {
    this._forEachExtensions((extension) => extension.onLoading && extension.onLoading());
  }
  _extensionsOnReady() {
    this._forEachExtensions((extension) => extension.onReady && extension.onReady());
  }
  _extensionsLoadSceneAsync(context, scene) {
    return this._applyExtensions(scene, "loadScene", (extension) => extension.loadSceneAsync && extension.loadSceneAsync(context, scene));
  }
  _extensionsLoadNodeAsync(context, node, assign) {
    return this._applyExtensions(node, "loadNode", (extension) => extension.loadNodeAsync && extension.loadNodeAsync(context, node, assign));
  }
  _extensionsLoadCameraAsync(context, camera, assign) {
    return this._applyExtensions(camera, "loadCamera", (extension) => extension.loadCameraAsync && extension.loadCameraAsync(context, camera, assign));
  }
  _extensionsLoadVertexDataAsync(context, primitive, babylonMesh) {
    return this._applyExtensions(primitive, "loadVertexData", (extension) => extension._loadVertexDataAsync && extension._loadVertexDataAsync(context, primitive, babylonMesh));
  }
  _extensionsLoadMeshPrimitiveAsync(context, name, node, mesh, primitive, assign) {
    return this._applyExtensions(primitive, "loadMeshPrimitive", (extension) => extension._loadMeshPrimitiveAsync && extension._loadMeshPrimitiveAsync(context, name, node, mesh, primitive, assign));
  }
  _extensionsLoadMaterialAsync(context, material, babylonMesh, babylonDrawMode, assign) {
    return this._applyExtensions(material, "loadMaterial", (extension) => extension._loadMaterialAsync && extension._loadMaterialAsync(context, material, babylonMesh, babylonDrawMode, assign));
  }
  _extensionsCreateMaterial(context, material, babylonDrawMode) {
    return this._applyExtensions(material, "createMaterial", (extension) => extension.createMaterial && extension.createMaterial(context, material, babylonDrawMode));
  }
  _extensionsLoadMaterialPropertiesAsync(context, material, babylonMaterial) {
    return this._applyExtensions(material, "loadMaterialProperties", (extension) => extension.loadMaterialPropertiesAsync && extension.loadMaterialPropertiesAsync(context, material, babylonMaterial));
  }
  _extensionsLoadTextureInfoAsync(context, textureInfo, assign) {
    return this._applyExtensions(textureInfo, "loadTextureInfo", (extension) => extension.loadTextureInfoAsync && extension.loadTextureInfoAsync(context, textureInfo, assign));
  }
  _extensionsLoadTextureAsync(context, texture, assign) {
    return this._applyExtensions(texture, "loadTexture", (extension) => extension._loadTextureAsync && extension._loadTextureAsync(context, texture, assign));
  }
  _extensionsLoadAnimationAsync(context, animation) {
    return this._applyExtensions(animation, "loadAnimation", (extension) => extension.loadAnimationAsync && extension.loadAnimationAsync(context, animation));
  }
  _extensionsLoadAnimationChannelAsync(context, animationContext, animation, channel, onLoad) {
    return this._applyExtensions(animation, "loadAnimationChannel", (extension) => extension._loadAnimationChannelAsync && extension._loadAnimationChannelAsync(context, animationContext, animation, channel, onLoad));
  }
  _extensionsLoadSkinAsync(context, node, skin) {
    return this._applyExtensions(skin, "loadSkin", (extension) => extension._loadSkinAsync && extension._loadSkinAsync(context, node, skin));
  }
  _extensionsLoadUriAsync(context, property, uri) {
    return this._applyExtensions(property, "loadUri", (extension) => extension._loadUriAsync && extension._loadUriAsync(context, property, uri));
  }
  _extensionsLoadBufferViewAsync(context, bufferView) {
    return this._applyExtensions(bufferView, "loadBufferView", (extension) => extension.loadBufferViewAsync && extension.loadBufferViewAsync(context, bufferView));
  }
  _extensionsLoadBufferAsync(context, buffer, byteOffset, byteLength) {
    return this._applyExtensions(buffer, "loadBuffer", (extension) => extension.loadBufferAsync && extension.loadBufferAsync(context, buffer, byteOffset, byteLength));
  }
  static LoadExtensionAsync(context, property, extensionName, actionAsync) {
    if (!property.extensions) {
      return null;
    }
    const extensions = property.extensions;
    const extension = extensions[extensionName];
    if (!extension) {
      return null;
    }
    return actionAsync(`${context}/extensions/${extensionName}`, extension);
  }
  static LoadExtraAsync(context, property, extensionName, actionAsync) {
    if (!property.extras) {
      return null;
    }
    const extras = property.extras;
    const extra = extras[extensionName];
    if (!extra) {
      return null;
    }
    return actionAsync(`${context}/extras/${extensionName}`, extra);
  }
  isExtensionUsed(name) {
    return !!this._gltf.extensionsUsed && this._gltf.extensionsUsed.indexOf(name) !== -1;
  }
  logOpen(message) {
    this._parent._logOpen(message);
  }
  logClose() {
    this._parent._logClose();
  }
  log(message) {
    this._parent._log(message);
  }
  startPerformanceCounter(counterName) {
    this._parent._startPerformanceCounter(counterName);
  }
  endPerformanceCounter(counterName) {
    this._parent._endPerformanceCounter(counterName);
  }
};
GLTFLoader2._RegisteredExtensions = {};
GLTFLoader2.DefaultSampler = { index: -1 };
GLTFFileLoader._CreateGLTF2Loader = (parent) => new GLTFLoader2(parent);

// node_modules/@babylonjs/loaders/glTF/2.0/Extensions/EXT_lights_image_based.js
var NAME = "EXT_lights_image_based";
var EXT_lights_image_based = class {
  constructor(loader) {
    this.name = NAME;
    this._loader = loader;
    this.enabled = this._loader.isExtensionUsed(NAME);
  }
  dispose() {
    this._loader = null;
    delete this._lights;
  }
  onLoading() {
    const extensions = this._loader.gltf.extensions;
    if (extensions && extensions[this.name]) {
      const extension = extensions[this.name];
      this._lights = extension.lights;
    }
  }
  loadSceneAsync(context, scene) {
    return GLTFLoader2.LoadExtensionAsync(context, scene, this.name, (extensionContext, extension) => {
      const promises = new Array();
      promises.push(this._loader.loadSceneAsync(context, scene));
      this._loader.logOpen(`${extensionContext}`);
      const light = ArrayItem.Get(`${extensionContext}/light`, this._lights, extension.light);
      promises.push(this._loadLightAsync(`/extensions/${this.name}/lights/${extension.light}`, light).then((texture) => {
        this._loader.babylonScene.environmentTexture = texture;
      }));
      this._loader.logClose();
      return Promise.all(promises).then(() => {
      });
    });
  }
  _loadLightAsync(context, light) {
    if (!light._loaded) {
      const promises = new Array();
      this._loader.logOpen(`${context}`);
      const imageData = new Array(light.specularImages.length);
      for (let mipmap = 0; mipmap < light.specularImages.length; mipmap++) {
        const faces = light.specularImages[mipmap];
        imageData[mipmap] = new Array(faces.length);
        for (let face = 0; face < faces.length; face++) {
          const specularImageContext = `${context}/specularImages/${mipmap}/${face}`;
          this._loader.logOpen(`${specularImageContext}`);
          const index = faces[face];
          const image = ArrayItem.Get(specularImageContext, this._loader.gltf.images, index);
          promises.push(this._loader.loadImageAsync(`/images/${index}`, image).then((data) => {
            imageData[mipmap][face] = data;
          }));
          this._loader.logClose();
        }
      }
      this._loader.logClose();
      light._loaded = Promise.all(promises).then(() => {
        const babylonTexture = new RawCubeTexture(this._loader.babylonScene, null, light.specularImageSize);
        babylonTexture.name = light.name || "environment";
        light._babylonTexture = babylonTexture;
        if (light.intensity != void 0) {
          babylonTexture.level = light.intensity;
        }
        if (light.rotation) {
          let rotation = Quaternion.FromArray(light.rotation);
          if (!this._loader.babylonScene.useRightHandedSystem) {
            rotation = Quaternion.Inverse(rotation);
          }
          Matrix.FromQuaternionToRef(rotation, babylonTexture.getReflectionTextureMatrix());
        }
        if (!light.irradianceCoefficients) {
          throw new Error(`${context}: Irradiance coefficients are missing`);
        }
        const sphericalHarmonics = SphericalHarmonics.FromArray(light.irradianceCoefficients);
        sphericalHarmonics.scaleInPlace(light.intensity);
        sphericalHarmonics.convertIrradianceToLambertianRadiance();
        const sphericalPolynomial = SphericalPolynomial.FromHarmonics(sphericalHarmonics);
        const lodGenerationScale = (imageData.length - 1) / Scalar.Log2(light.specularImageSize);
        return babylonTexture.updateRGBDAsync(imageData, sphericalPolynomial, lodGenerationScale);
      });
    }
    return light._loaded.then(() => {
      return light._babylonTexture;
    });
  }
};
GLTFLoader2.RegisterExtension(NAME, (loader) => new EXT_lights_image_based(loader));

// node_modules/@babylonjs/loaders/glTF/2.0/Extensions/EXT_mesh_gpu_instancing.js
var NAME2 = "EXT_mesh_gpu_instancing";
var EXT_mesh_gpu_instancing = class {
  constructor(loader) {
    this.name = NAME2;
    this._loader = loader;
    this.enabled = this._loader.isExtensionUsed(NAME2);
  }
  dispose() {
    this._loader = null;
  }
  loadNodeAsync(context, node, assign) {
    return GLTFLoader2.LoadExtensionAsync(context, node, this.name, (extensionContext, extension) => {
      this._loader._disableInstancedMesh++;
      const promise = this._loader.loadNodeAsync(`/nodes/${node.index}`, node, assign);
      this._loader._disableInstancedMesh--;
      if (!node._primitiveBabylonMeshes) {
        return promise;
      }
      const promises = new Array();
      let instanceCount = 0;
      const loadAttribute = (attribute) => {
        if (extension.attributes[attribute] == void 0) {
          promises.push(Promise.resolve(null));
          return;
        }
        const accessor = ArrayItem.Get(`${extensionContext}/attributes/${attribute}`, this._loader.gltf.accessors, extension.attributes[attribute]);
        promises.push(this._loader._loadFloatAccessorAsync(`/accessors/${accessor.bufferView}`, accessor));
        if (instanceCount === 0) {
          instanceCount = accessor.count;
        } else if (instanceCount !== accessor.count) {
          throw new Error(`${extensionContext}/attributes: Instance buffer accessors do not have the same count.`);
        }
      };
      loadAttribute("TRANSLATION");
      loadAttribute("ROTATION");
      loadAttribute("SCALE");
      return promise.then((babylonTransformNode) => {
        return Promise.all(promises).then(([translationBuffer, rotationBuffer, scaleBuffer]) => {
          const matrices = new Float32Array(instanceCount * 16);
          TmpVectors.Vector3[0].copyFromFloats(0, 0, 0);
          TmpVectors.Quaternion[0].copyFromFloats(0, 0, 0, 1);
          TmpVectors.Vector3[1].copyFromFloats(1, 1, 1);
          for (let i = 0; i < instanceCount; ++i) {
            translationBuffer && Vector3.FromArrayToRef(translationBuffer, i * 3, TmpVectors.Vector3[0]);
            rotationBuffer && Quaternion.FromArrayToRef(rotationBuffer, i * 4, TmpVectors.Quaternion[0]);
            scaleBuffer && Vector3.FromArrayToRef(scaleBuffer, i * 3, TmpVectors.Vector3[1]);
            Matrix.ComposeToRef(TmpVectors.Vector3[1], TmpVectors.Quaternion[0], TmpVectors.Vector3[0], TmpVectors.Matrix[0]);
            TmpVectors.Matrix[0].copyToArray(matrices, i * 16);
          }
          for (const babylonMesh of node._primitiveBabylonMeshes) {
            babylonMesh.thinInstanceSetBuffer("matrix", matrices, 16, true);
          }
          return babylonTransformNode;
        });
      });
    });
  }
};
GLTFLoader2.RegisterExtension(NAME2, (loader) => new EXT_mesh_gpu_instancing(loader));

// node_modules/@babylonjs/loaders/glTF/2.0/Extensions/EXT_meshopt_compression.js
var NAME3 = "EXT_meshopt_compression";
var EXT_meshopt_compression = class {
  constructor(loader) {
    this.name = NAME3;
    this.enabled = loader.isExtensionUsed(NAME3);
    this._loader = loader;
  }
  dispose() {
    this._loader = null;
  }
  loadBufferViewAsync(context, bufferView) {
    return GLTFLoader2.LoadExtensionAsync(context, bufferView, this.name, (extensionContext, extension) => {
      const bufferViewMeshopt = bufferView;
      if (bufferViewMeshopt._meshOptData) {
        return bufferViewMeshopt._meshOptData;
      }
      const buffer = ArrayItem.Get(`${context}/buffer`, this._loader.gltf.buffers, extension.buffer);
      bufferViewMeshopt._meshOptData = this._loader.loadBufferAsync(`/buffers/${buffer.index}`, buffer, extension.byteOffset || 0, extension.byteLength).then((buffer2) => {
        return MeshoptCompression.Default.decodeGltfBufferAsync(buffer2, extension.count, extension.byteStride, extension.mode, extension.filter);
      });
      return bufferViewMeshopt._meshOptData;
    });
  }
};
GLTFLoader2.RegisterExtension(NAME3, (loader) => new EXT_meshopt_compression(loader));

// node_modules/@babylonjs/loaders/glTF/2.0/Extensions/EXT_texture_webp.js
var NAME4 = "EXT_texture_webp";
var EXT_texture_webp = class {
  constructor(loader) {
    this.name = NAME4;
    this._loader = loader;
    this.enabled = loader.isExtensionUsed(NAME4);
  }
  dispose() {
    this._loader = null;
  }
  _loadTextureAsync(context, texture, assign) {
    return GLTFLoader2.LoadExtensionAsync(context, texture, this.name, (extensionContext, extension) => {
      const sampler = texture.sampler == void 0 ? GLTFLoader2.DefaultSampler : ArrayItem.Get(`${context}/sampler`, this._loader.gltf.samplers, texture.sampler);
      const image = ArrayItem.Get(`${extensionContext}/source`, this._loader.gltf.images, extension.source);
      return this._loader._createTextureAsync(context, sampler, image, (babylonTexture) => {
        assign(babylonTexture);
      }, void 0, !texture._textureInfo.nonColorData);
    });
  }
};
GLTFLoader2.RegisterExtension(NAME4, (loader) => new EXT_texture_webp(loader));

// node_modules/@babylonjs/loaders/glTF/2.0/Extensions/KHR_draco_mesh_compression.js
var NAME5 = "KHR_draco_mesh_compression";
var KHR_draco_mesh_compression = class {
  constructor(loader) {
    this.name = NAME5;
    this._loader = loader;
    this.enabled = DracoCompression.DecoderAvailable && this._loader.isExtensionUsed(NAME5);
  }
  dispose() {
    delete this.dracoCompression;
    this._loader = null;
  }
  _loadVertexDataAsync(context, primitive, babylonMesh) {
    return GLTFLoader2.LoadExtensionAsync(context, primitive, this.name, (extensionContext, extension) => {
      if (primitive.mode != void 0) {
        if (primitive.mode !== 5 && primitive.mode !== 4) {
          throw new Error(`${context}: Unsupported mode ${primitive.mode}`);
        }
        if (primitive.mode === 5) {
          throw new Error(`${context}: Mode ${primitive.mode} is not currently supported`);
        }
      }
      const attributes = {};
      const dividers = {};
      const loadAttribute = (name, kind) => {
        const uniqueId = extension.attributes[name];
        if (uniqueId === void 0 || primitive.attributes[name] === void 0) {
          return;
        }
        attributes[kind] = uniqueId;
        const accessor = ArrayItem.Get(`${context}/attributes/${name}`, this._loader.gltf.accessors, primitive.attributes[name]);
        if (accessor.normalized && accessor.componentType !== 5126) {
          let divider = 1;
          switch (accessor.componentType) {
            case 5120:
              divider = 127;
              break;
            case 5121:
              divider = 255;
              break;
            case 5122:
              divider = 32767;
              break;
            case 5123:
              divider = 65535;
              break;
          }
          dividers[kind] = divider;
        }
        babylonMesh._delayInfo = babylonMesh._delayInfo || [];
        if (babylonMesh._delayInfo.indexOf(kind) === -1) {
          babylonMesh._delayInfo.push(kind);
        }
      };
      loadAttribute("POSITION", VertexBuffer.PositionKind);
      loadAttribute("NORMAL", VertexBuffer.NormalKind);
      loadAttribute("TANGENT", VertexBuffer.TangentKind);
      loadAttribute("TEXCOORD_0", VertexBuffer.UVKind);
      loadAttribute("TEXCOORD_1", VertexBuffer.UV2Kind);
      loadAttribute("TEXCOORD_2", VertexBuffer.UV3Kind);
      loadAttribute("TEXCOORD_3", VertexBuffer.UV4Kind);
      loadAttribute("TEXCOORD_4", VertexBuffer.UV5Kind);
      loadAttribute("TEXCOORD_5", VertexBuffer.UV6Kind);
      loadAttribute("JOINTS_0", VertexBuffer.MatricesIndicesKind);
      loadAttribute("WEIGHTS_0", VertexBuffer.MatricesWeightsKind);
      loadAttribute("COLOR_0", VertexBuffer.ColorKind);
      const bufferView = ArrayItem.Get(extensionContext, this._loader.gltf.bufferViews, extension.bufferView);
      if (!bufferView._dracoBabylonGeometry) {
        bufferView._dracoBabylonGeometry = this._loader.loadBufferViewAsync(`/bufferViews/${bufferView.index}`, bufferView).then((data) => {
          const dracoCompression = this.dracoCompression || DracoCompression.Default;
          return dracoCompression.decodeMeshAsync(data, attributes, dividers).then((babylonVertexData) => {
            const babylonGeometry = new Geometry(babylonMesh.name, this._loader.babylonScene);
            babylonVertexData.applyToGeometry(babylonGeometry);
            return babylonGeometry;
          }).catch((error) => {
            throw new Error(`${context}: ${error.message}`);
          });
        });
      }
      return bufferView._dracoBabylonGeometry;
    });
  }
};
GLTFLoader2.RegisterExtension(NAME5, (loader) => new KHR_draco_mesh_compression(loader));

// node_modules/@babylonjs/loaders/glTF/2.0/Extensions/KHR_lights_punctual.js
var NAME6 = "KHR_lights_punctual";
var KHR_lights = class {
  constructor(loader) {
    this.name = NAME6;
    this._loader = loader;
    this.enabled = this._loader.isExtensionUsed(NAME6);
  }
  dispose() {
    this._loader = null;
    delete this._lights;
  }
  onLoading() {
    const extensions = this._loader.gltf.extensions;
    if (extensions && extensions[this.name]) {
      const extension = extensions[this.name];
      this._lights = extension.lights;
      ArrayItem.Assign(this._lights);
    }
  }
  loadNodeAsync(context, node, assign) {
    return GLTFLoader2.LoadExtensionAsync(context, node, this.name, (extensionContext, extension) => {
      return this._loader.loadNodeAsync(context, node, (babylonMesh) => {
        let babylonLight;
        const light = ArrayItem.Get(extensionContext, this._lights, extension.light);
        const name = light.name || babylonMesh.name;
        this._loader.babylonScene._blockEntityCollection = !!this._loader._assetContainer;
        switch (light.type) {
          case "directional": {
            babylonLight = new DirectionalLight(name, Vector3.Backward(), this._loader.babylonScene);
            break;
          }
          case "point": {
            babylonLight = new PointLight(name, Vector3.Zero(), this._loader.babylonScene);
            break;
          }
          case "spot": {
            const babylonSpotLight = new SpotLight(name, Vector3.Zero(), Vector3.Backward(), 0, 1, this._loader.babylonScene);
            babylonSpotLight.angle = (light.spot && light.spot.outerConeAngle || Math.PI / 4) * 2;
            babylonSpotLight.innerAngle = (light.spot && light.spot.innerConeAngle || 0) * 2;
            babylonLight = babylonSpotLight;
            break;
          }
          default: {
            this._loader.babylonScene._blockEntityCollection = false;
            throw new Error(`${extensionContext}: Invalid light type (${light.type})`);
          }
        }
        babylonLight._parentContainer = this._loader._assetContainer;
        this._loader.babylonScene._blockEntityCollection = false;
        light._babylonLight = babylonLight;
        babylonLight.falloffType = Light.FALLOFF_GLTF;
        babylonLight.diffuse = light.color ? Color3.FromArray(light.color) : Color3.White();
        babylonLight.intensity = light.intensity == void 0 ? 1 : light.intensity;
        babylonLight.range = light.range == void 0 ? Number.MAX_VALUE : light.range;
        babylonLight.parent = babylonMesh;
        this._loader._babylonLights.push(babylonLight);
        GLTFLoader2.AddPointerMetadata(babylonLight, extensionContext);
        assign(babylonMesh);
      });
    });
  }
};
GLTFLoader2.RegisterExtension(NAME6, (loader) => new KHR_lights(loader));

// node_modules/@babylonjs/loaders/glTF/2.0/Extensions/KHR_materials_pbrSpecularGlossiness.js
var NAME7 = "KHR_materials_pbrSpecularGlossiness";
var KHR_materials_pbrSpecularGlossiness = class {
  constructor(loader) {
    this.name = NAME7;
    this.order = 200;
    this._loader = loader;
    this.enabled = this._loader.isExtensionUsed(NAME7);
  }
  dispose() {
    this._loader = null;
  }
  loadMaterialPropertiesAsync(context, material, babylonMaterial) {
    return GLTFLoader2.LoadExtensionAsync(context, material, this.name, (extensionContext, extension) => {
      const promises = new Array();
      promises.push(this._loader.loadMaterialBasePropertiesAsync(context, material, babylonMaterial));
      promises.push(this._loadSpecularGlossinessPropertiesAsync(extensionContext, material, extension, babylonMaterial));
      this._loader.loadMaterialAlphaProperties(context, material, babylonMaterial);
      return Promise.all(promises).then(() => {
      });
    });
  }
  _loadSpecularGlossinessPropertiesAsync(context, material, properties, babylonMaterial) {
    if (!(babylonMaterial instanceof PBRMaterial)) {
      throw new Error(`${context}: Material type not supported`);
    }
    const promises = new Array();
    babylonMaterial.metallic = null;
    babylonMaterial.roughness = null;
    if (properties.diffuseFactor) {
      babylonMaterial.albedoColor = Color3.FromArray(properties.diffuseFactor);
      babylonMaterial.alpha = properties.diffuseFactor[3];
    } else {
      babylonMaterial.albedoColor = Color3.White();
    }
    babylonMaterial.reflectivityColor = properties.specularFactor ? Color3.FromArray(properties.specularFactor) : Color3.White();
    babylonMaterial.microSurface = properties.glossinessFactor == void 0 ? 1 : properties.glossinessFactor;
    if (properties.diffuseTexture) {
      promises.push(this._loader.loadTextureInfoAsync(`${context}/diffuseTexture`, properties.diffuseTexture, (texture) => {
        texture.name = `${babylonMaterial.name} (Diffuse)`;
        babylonMaterial.albedoTexture = texture;
      }));
    }
    if (properties.specularGlossinessTexture) {
      promises.push(this._loader.loadTextureInfoAsync(`${context}/specularGlossinessTexture`, properties.specularGlossinessTexture, (texture) => {
        texture.name = `${babylonMaterial.name} (Specular Glossiness)`;
        babylonMaterial.reflectivityTexture = texture;
        babylonMaterial.reflectivityTexture.hasAlpha = true;
      }));
      babylonMaterial.useMicroSurfaceFromReflectivityMapAlpha = true;
    }
    return Promise.all(promises).then(() => {
    });
  }
};
GLTFLoader2.RegisterExtension(NAME7, (loader) => new KHR_materials_pbrSpecularGlossiness(loader));

// node_modules/@babylonjs/loaders/glTF/2.0/Extensions/KHR_materials_unlit.js
var NAME8 = "KHR_materials_unlit";
var KHR_materials_unlit = class {
  constructor(loader) {
    this.name = NAME8;
    this.order = 210;
    this._loader = loader;
    this.enabled = this._loader.isExtensionUsed(NAME8);
  }
  dispose() {
    this._loader = null;
  }
  loadMaterialPropertiesAsync(context, material, babylonMaterial) {
    return GLTFLoader2.LoadExtensionAsync(context, material, this.name, () => {
      return this._loadUnlitPropertiesAsync(context, material, babylonMaterial);
    });
  }
  _loadUnlitPropertiesAsync(context, material, babylonMaterial) {
    if (!(babylonMaterial instanceof PBRMaterial)) {
      throw new Error(`${context}: Material type not supported`);
    }
    const promises = new Array();
    babylonMaterial.unlit = true;
    const properties = material.pbrMetallicRoughness;
    if (properties) {
      if (properties.baseColorFactor) {
        babylonMaterial.albedoColor = Color3.FromArray(properties.baseColorFactor);
        babylonMaterial.alpha = properties.baseColorFactor[3];
      } else {
        babylonMaterial.albedoColor = Color3.White();
      }
      if (properties.baseColorTexture) {
        promises.push(this._loader.loadTextureInfoAsync(`${context}/baseColorTexture`, properties.baseColorTexture, (texture) => {
          texture.name = `${babylonMaterial.name} (Base Color)`;
          babylonMaterial.albedoTexture = texture;
        }));
      }
    }
    if (material.doubleSided) {
      babylonMaterial.backFaceCulling = false;
      babylonMaterial.twoSidedLighting = true;
    }
    this._loader.loadMaterialAlphaProperties(context, material, babylonMaterial);
    return Promise.all(promises).then(() => {
    });
  }
};
GLTFLoader2.RegisterExtension(NAME8, (loader) => new KHR_materials_unlit(loader));

// node_modules/@babylonjs/loaders/glTF/2.0/Extensions/KHR_materials_clearcoat.js
var NAME9 = "KHR_materials_clearcoat";
var KHR_materials_clearcoat = class {
  constructor(loader) {
    this.name = NAME9;
    this.order = 190;
    this._loader = loader;
    this.enabled = this._loader.isExtensionUsed(NAME9);
  }
  dispose() {
    this._loader = null;
  }
  loadMaterialPropertiesAsync(context, material, babylonMaterial) {
    return GLTFLoader2.LoadExtensionAsync(context, material, this.name, (extensionContext, extension) => {
      const promises = new Array();
      promises.push(this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));
      promises.push(this._loadClearCoatPropertiesAsync(extensionContext, extension, babylonMaterial));
      return Promise.all(promises).then(() => {
      });
    });
  }
  _loadClearCoatPropertiesAsync(context, properties, babylonMaterial) {
    if (!(babylonMaterial instanceof PBRMaterial)) {
      throw new Error(`${context}: Material type not supported`);
    }
    const promises = new Array();
    babylonMaterial.clearCoat.isEnabled = true;
    babylonMaterial.clearCoat.useRoughnessFromMainTexture = false;
    babylonMaterial.clearCoat.remapF0OnInterfaceChange = false;
    if (properties.clearcoatFactor != void 0) {
      babylonMaterial.clearCoat.intensity = properties.clearcoatFactor;
    } else {
      babylonMaterial.clearCoat.intensity = 0;
    }
    if (properties.clearcoatTexture) {
      promises.push(this._loader.loadTextureInfoAsync(`${context}/clearcoatTexture`, properties.clearcoatTexture, (texture) => {
        texture.name = `${babylonMaterial.name} (ClearCoat Intensity)`;
        babylonMaterial.clearCoat.texture = texture;
      }));
    }
    if (properties.clearcoatRoughnessFactor != void 0) {
      babylonMaterial.clearCoat.roughness = properties.clearcoatRoughnessFactor;
    } else {
      babylonMaterial.clearCoat.roughness = 0;
    }
    if (properties.clearcoatRoughnessTexture) {
      properties.clearcoatRoughnessTexture.nonColorData = true;
      promises.push(this._loader.loadTextureInfoAsync(`${context}/clearcoatRoughnessTexture`, properties.clearcoatRoughnessTexture, (texture) => {
        texture.name = `${babylonMaterial.name} (ClearCoat Roughness)`;
        babylonMaterial.clearCoat.textureRoughness = texture;
      }));
    }
    if (properties.clearcoatNormalTexture) {
      properties.clearcoatNormalTexture.nonColorData = true;
      promises.push(this._loader.loadTextureInfoAsync(`${context}/clearcoatNormalTexture`, properties.clearcoatNormalTexture, (texture) => {
        texture.name = `${babylonMaterial.name} (ClearCoat Normal)`;
        babylonMaterial.clearCoat.bumpTexture = texture;
      }));
      babylonMaterial.invertNormalMapX = !babylonMaterial.getScene().useRightHandedSystem;
      babylonMaterial.invertNormalMapY = babylonMaterial.getScene().useRightHandedSystem;
      if (properties.clearcoatNormalTexture.scale != void 0) {
        babylonMaterial.clearCoat.bumpTexture.level = properties.clearcoatNormalTexture.scale;
      }
    }
    return Promise.all(promises).then(() => {
    });
  }
};
GLTFLoader2.RegisterExtension(NAME9, (loader) => new KHR_materials_clearcoat(loader));

// node_modules/@babylonjs/loaders/glTF/2.0/Extensions/KHR_materials_iridescence.js
var NAME10 = "KHR_materials_iridescence";
var KHR_materials_iridescence = class {
  constructor(loader) {
    this.name = NAME10;
    this.order = 195;
    this._loader = loader;
    this.enabled = this._loader.isExtensionUsed(NAME10);
  }
  dispose() {
    this._loader = null;
  }
  loadMaterialPropertiesAsync(context, material, babylonMaterial) {
    return GLTFLoader2.LoadExtensionAsync(context, material, this.name, (extensionContext, extension) => {
      const promises = new Array();
      promises.push(this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));
      promises.push(this._loadIridescencePropertiesAsync(extensionContext, extension, babylonMaterial));
      return Promise.all(promises).then(() => {
      });
    });
  }
  _loadIridescencePropertiesAsync(context, properties, babylonMaterial) {
    var _a, _b, _c, _d, _e;
    if (!(babylonMaterial instanceof PBRMaterial)) {
      throw new Error(`${context}: Material type not supported`);
    }
    const promises = new Array();
    babylonMaterial.iridescence.isEnabled = true;
    babylonMaterial.iridescence.intensity = (_a = properties.iridescenceFactor) !== null && _a !== void 0 ? _a : 0;
    babylonMaterial.iridescence.indexOfRefraction = (_c = (_b = properties.iridescenceIor) !== null && _b !== void 0 ? _b : properties.iridescenceIOR) !== null && _c !== void 0 ? _c : 1.3;
    babylonMaterial.iridescence.minimumThickness = (_d = properties.iridescenceThicknessMinimum) !== null && _d !== void 0 ? _d : 100;
    babylonMaterial.iridescence.maximumThickness = (_e = properties.iridescenceThicknessMaximum) !== null && _e !== void 0 ? _e : 400;
    if (properties.iridescenceTexture) {
      promises.push(this._loader.loadTextureInfoAsync(`${context}/iridescenceTexture`, properties.iridescenceTexture, (texture) => {
        texture.name = `${babylonMaterial.name} (Iridescence Intensity)`;
        babylonMaterial.iridescence.texture = texture;
      }));
    }
    if (properties.iridescenceThicknessTexture) {
      promises.push(this._loader.loadTextureInfoAsync(`${context}/iridescenceThicknessTexture`, properties.iridescenceThicknessTexture, (texture) => {
        texture.name = `${babylonMaterial.name} (Iridescence Thickness)`;
        babylonMaterial.iridescence.thicknessTexture = texture;
      }));
    }
    return Promise.all(promises).then(() => {
    });
  }
};
GLTFLoader2.RegisterExtension(NAME10, (loader) => new KHR_materials_iridescence(loader));

// node_modules/@babylonjs/loaders/glTF/2.0/Extensions/KHR_materials_emissive_strength.js
var NAME11 = "KHR_materials_emissive_strength";
var KHR_materials_emissive_strength = class {
  constructor(loader) {
    this.name = NAME11;
    this.order = 170;
    this._loader = loader;
    this.enabled = this._loader.isExtensionUsed(NAME11);
  }
  dispose() {
    this._loader = null;
  }
  loadMaterialPropertiesAsync(context, material, babylonMaterial) {
    return GLTFLoader2.LoadExtensionAsync(context, material, this.name, (extensionContext, extension) => {
      return this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial).then(() => {
        this._loadEmissiveProperties(extensionContext, extension, babylonMaterial);
      });
    });
  }
  _loadEmissiveProperties(context, properties, babylonMaterial) {
    if (!(babylonMaterial instanceof PBRMaterial)) {
      throw new Error(`${context}: Material type not supported`);
    }
    if (properties.emissiveStrength !== void 0) {
      babylonMaterial.emissiveColor.scaleToRef(properties.emissiveStrength, babylonMaterial.emissiveColor);
    }
  }
};
GLTFLoader2.RegisterExtension(NAME11, (loader) => new KHR_materials_emissive_strength(loader));

// node_modules/@babylonjs/loaders/glTF/2.0/Extensions/KHR_materials_sheen.js
var NAME12 = "KHR_materials_sheen";
var KHR_materials_sheen = class {
  constructor(loader) {
    this.name = NAME12;
    this.order = 190;
    this._loader = loader;
    this.enabled = this._loader.isExtensionUsed(NAME12);
  }
  dispose() {
    this._loader = null;
  }
  loadMaterialPropertiesAsync(context, material, babylonMaterial) {
    return GLTFLoader2.LoadExtensionAsync(context, material, this.name, (extensionContext, extension) => {
      const promises = new Array();
      promises.push(this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));
      promises.push(this._loadSheenPropertiesAsync(extensionContext, extension, babylonMaterial));
      return Promise.all(promises).then(() => {
      });
    });
  }
  _loadSheenPropertiesAsync(context, properties, babylonMaterial) {
    if (!(babylonMaterial instanceof PBRMaterial)) {
      throw new Error(`${context}: Material type not supported`);
    }
    const promises = new Array();
    babylonMaterial.sheen.isEnabled = true;
    babylonMaterial.sheen.intensity = 1;
    if (properties.sheenColorFactor != void 0) {
      babylonMaterial.sheen.color = Color3.FromArray(properties.sheenColorFactor);
    } else {
      babylonMaterial.sheen.color = Color3.Black();
    }
    if (properties.sheenColorTexture) {
      promises.push(this._loader.loadTextureInfoAsync(`${context}/sheenColorTexture`, properties.sheenColorTexture, (texture) => {
        texture.name = `${babylonMaterial.name} (Sheen Color)`;
        babylonMaterial.sheen.texture = texture;
      }));
    }
    if (properties.sheenRoughnessFactor !== void 0) {
      babylonMaterial.sheen.roughness = properties.sheenRoughnessFactor;
    } else {
      babylonMaterial.sheen.roughness = 0;
    }
    if (properties.sheenRoughnessTexture) {
      properties.sheenRoughnessTexture.nonColorData = true;
      promises.push(this._loader.loadTextureInfoAsync(`${context}/sheenRoughnessTexture`, properties.sheenRoughnessTexture, (texture) => {
        texture.name = `${babylonMaterial.name} (Sheen Roughness)`;
        babylonMaterial.sheen.textureRoughness = texture;
      }));
    }
    babylonMaterial.sheen.albedoScaling = true;
    babylonMaterial.sheen.useRoughnessFromMainTexture = false;
    return Promise.all(promises).then(() => {
    });
  }
};
GLTFLoader2.RegisterExtension(NAME12, (loader) => new KHR_materials_sheen(loader));

// node_modules/@babylonjs/loaders/glTF/2.0/Extensions/KHR_materials_specular.js
var NAME13 = "KHR_materials_specular";
var KHR_materials_specular = class {
  constructor(loader) {
    this.name = NAME13;
    this.order = 190;
    this._loader = loader;
    this.enabled = this._loader.isExtensionUsed(NAME13);
  }
  dispose() {
    this._loader = null;
  }
  loadMaterialPropertiesAsync(context, material, babylonMaterial) {
    return GLTFLoader2.LoadExtensionAsync(context, material, this.name, (extensionContext, extension) => {
      const promises = new Array();
      promises.push(this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));
      promises.push(this._loadSpecularPropertiesAsync(extensionContext, extension, babylonMaterial));
      return Promise.all(promises).then(() => {
      });
    });
  }
  _loadSpecularPropertiesAsync(context, properties, babylonMaterial) {
    if (!(babylonMaterial instanceof PBRMaterial)) {
      throw new Error(`${context}: Material type not supported`);
    }
    const promises = new Array();
    if (properties.specularFactor !== void 0) {
      babylonMaterial.metallicF0Factor = properties.specularFactor;
    }
    if (properties.specularColorFactor !== void 0) {
      babylonMaterial.metallicReflectanceColor = Color3.FromArray(properties.specularColorFactor);
    }
    if (properties.specularTexture) {
      properties.specularTexture.nonColorData = true;
      promises.push(this._loader.loadTextureInfoAsync(`${context}/specularTexture`, properties.specularTexture, (texture) => {
        texture.name = `${babylonMaterial.name} (Specular F0 Strength)`;
        babylonMaterial.metallicReflectanceTexture = texture;
        babylonMaterial.useOnlyMetallicFromMetallicReflectanceTexture = true;
      }));
    }
    if (properties.specularColorTexture) {
      promises.push(this._loader.loadTextureInfoAsync(`${context}/specularColorTexture`, properties.specularColorTexture, (texture) => {
        texture.name = `${babylonMaterial.name} (Specular F0 Color)`;
        babylonMaterial.reflectanceTexture = texture;
      }));
    }
    return Promise.all(promises).then(() => {
    });
  }
};
GLTFLoader2.RegisterExtension(NAME13, (loader) => new KHR_materials_specular(loader));

// node_modules/@babylonjs/loaders/glTF/2.0/Extensions/KHR_materials_ior.js
var NAME14 = "KHR_materials_ior";
var KHR_materials_ior = class {
  constructor(loader) {
    this.name = NAME14;
    this.order = 180;
    this._loader = loader;
    this.enabled = this._loader.isExtensionUsed(NAME14);
  }
  dispose() {
    this._loader = null;
  }
  loadMaterialPropertiesAsync(context, material, babylonMaterial) {
    return GLTFLoader2.LoadExtensionAsync(context, material, this.name, (extensionContext, extension) => {
      const promises = new Array();
      promises.push(this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));
      promises.push(this._loadIorPropertiesAsync(extensionContext, extension, babylonMaterial));
      return Promise.all(promises).then(() => {
      });
    });
  }
  _loadIorPropertiesAsync(context, properties, babylonMaterial) {
    if (!(babylonMaterial instanceof PBRMaterial)) {
      throw new Error(`${context}: Material type not supported`);
    }
    if (properties.ior !== void 0) {
      babylonMaterial.indexOfRefraction = properties.ior;
    } else {
      babylonMaterial.indexOfRefraction = KHR_materials_ior._DEFAULT_IOR;
    }
    return Promise.resolve();
  }
};
KHR_materials_ior._DEFAULT_IOR = 1.5;
GLTFLoader2.RegisterExtension(NAME14, (loader) => new KHR_materials_ior(loader));

// node_modules/@babylonjs/loaders/glTF/2.0/Extensions/KHR_materials_variants.js
var NAME15 = "KHR_materials_variants";
var KHR_materials_variants = class {
  constructor(loader) {
    this.name = NAME15;
    this._loader = loader;
    this.enabled = this._loader.isExtensionUsed(NAME15);
  }
  dispose() {
    this._loader = null;
  }
  static GetAvailableVariants(rootMesh) {
    const extensionMetadata = this._GetExtensionMetadata(rootMesh);
    if (!extensionMetadata) {
      return [];
    }
    return Object.keys(extensionMetadata.variants);
  }
  getAvailableVariants(rootMesh) {
    return KHR_materials_variants.GetAvailableVariants(rootMesh);
  }
  static SelectVariant(rootMesh, variantName) {
    const extensionMetadata = this._GetExtensionMetadata(rootMesh);
    if (!extensionMetadata) {
      throw new Error(`Cannot select variant on a glTF mesh that does not have the ${NAME15} extension`);
    }
    const select = (variantName2) => {
      const entries = extensionMetadata.variants[variantName2];
      if (entries) {
        for (const entry of entries) {
          entry.mesh.material = entry.material;
        }
      }
    };
    if (variantName instanceof Array) {
      for (const name of variantName) {
        select(name);
      }
    } else {
      select(variantName);
    }
    extensionMetadata.lastSelected = variantName;
  }
  selectVariant(rootMesh, variantName) {
    return KHR_materials_variants.SelectVariant(rootMesh, variantName);
  }
  static Reset(rootMesh) {
    const extensionMetadata = this._GetExtensionMetadata(rootMesh);
    if (!extensionMetadata) {
      throw new Error(`Cannot reset on a glTF mesh that does not have the ${NAME15} extension`);
    }
    for (const entry of extensionMetadata.original) {
      entry.mesh.material = entry.material;
    }
    extensionMetadata.lastSelected = null;
  }
  reset(rootMesh) {
    return KHR_materials_variants.Reset(rootMesh);
  }
  static GetLastSelectedVariant(rootMesh) {
    const extensionMetadata = this._GetExtensionMetadata(rootMesh);
    if (!extensionMetadata) {
      throw new Error(`Cannot get the last selected variant on a glTF mesh that does not have the ${NAME15} extension`);
    }
    return extensionMetadata.lastSelected;
  }
  getLastSelectedVariant(rootMesh) {
    return KHR_materials_variants.GetLastSelectedVariant(rootMesh);
  }
  static _GetExtensionMetadata(rootMesh) {
    var _a, _b;
    return ((_b = (_a = rootMesh === null || rootMesh === void 0 ? void 0 : rootMesh.metadata) === null || _a === void 0 ? void 0 : _a.gltf) === null || _b === void 0 ? void 0 : _b[NAME15]) || null;
  }
  onLoading() {
    const extensions = this._loader.gltf.extensions;
    if (extensions && extensions[this.name]) {
      const extension = extensions[this.name];
      this._variants = extension.variants;
    }
  }
  _loadMeshPrimitiveAsync(context, name, node, mesh, primitive, assign) {
    return GLTFLoader2.LoadExtensionAsync(context, primitive, this.name, (extensionContext, extension) => {
      const promises = new Array();
      promises.push(this._loader._loadMeshPrimitiveAsync(context, name, node, mesh, primitive, (babylonMesh) => {
        assign(babylonMesh);
        if (babylonMesh instanceof Mesh) {
          const babylonDrawMode = GLTFLoader2._GetDrawMode(context, primitive.mode);
          const root = this._loader.rootBabylonMesh;
          const metadata = root ? root.metadata = root.metadata || {} : {};
          const gltf = metadata.gltf = metadata.gltf || {};
          const extensionMetadata = gltf[NAME15] = gltf[NAME15] || { lastSelected: null, original: [], variants: {} };
          extensionMetadata.original.push({ mesh: babylonMesh, material: babylonMesh.material });
          for (let mappingIndex = 0; mappingIndex < extension.mappings.length; ++mappingIndex) {
            const mapping = extension.mappings[mappingIndex];
            const material = ArrayItem.Get(`${extensionContext}/mappings/${mappingIndex}/material`, this._loader.gltf.materials, mapping.material);
            promises.push(this._loader._loadMaterialAsync(`#/materials/${mapping.material}`, material, babylonMesh, babylonDrawMode, (babylonMaterial) => {
              for (let mappingVariantIndex = 0; mappingVariantIndex < mapping.variants.length; ++mappingVariantIndex) {
                const variantIndex = mapping.variants[mappingVariantIndex];
                const variant = ArrayItem.Get(`/extensions/${NAME15}/variants/${variantIndex}`, this._variants, variantIndex);
                extensionMetadata.variants[variant.name] = extensionMetadata.variants[variant.name] || [];
                extensionMetadata.variants[variant.name].push({
                  mesh: babylonMesh,
                  material: babylonMaterial
                });
                babylonMesh.onClonedObservable.add((newOne) => {
                  const newMesh = newOne;
                  let metadata2 = null;
                  let newRoot = newMesh;
                  do {
                    newRoot = newRoot.parent;
                    if (!newRoot) {
                      return;
                    }
                    metadata2 = KHR_materials_variants._GetExtensionMetadata(newRoot);
                  } while (metadata2 === null);
                  if (root && metadata2 === KHR_materials_variants._GetExtensionMetadata(root)) {
                    newRoot.metadata = {};
                    for (const key in root.metadata) {
                      newRoot.metadata[key] = root.metadata[key];
                    }
                    newRoot.metadata.gltf = [];
                    for (const key in root.metadata.gltf) {
                      newRoot.metadata.gltf[key] = root.metadata.gltf[key];
                    }
                    newRoot.metadata.gltf[NAME15] = { lastSelected: null, original: [], variants: {} };
                    for (const original of metadata2.original) {
                      newRoot.metadata.gltf[NAME15].original.push({
                        mesh: original.mesh,
                        material: original.material
                      });
                    }
                    for (const key in metadata2.variants) {
                      if (Object.prototype.hasOwnProperty.call(metadata2.variants, key)) {
                        newRoot.metadata.gltf[NAME15].variants[key] = [];
                        for (const variantEntry of metadata2.variants[key]) {
                          newRoot.metadata.gltf[NAME15].variants[key].push({
                            mesh: variantEntry.mesh,
                            material: variantEntry.material
                          });
                        }
                      }
                    }
                    metadata2 = newRoot.metadata.gltf[NAME15];
                  }
                  for (const target of metadata2.original) {
                    if (target.mesh === babylonMesh) {
                      target.mesh = newMesh;
                    }
                  }
                  for (const target of metadata2.variants[variant.name]) {
                    if (target.mesh === babylonMesh) {
                      target.mesh = newMesh;
                    }
                  }
                });
              }
            }));
          }
        }
      }));
      return Promise.all(promises).then(([babylonMesh]) => {
        return babylonMesh;
      });
    });
  }
};
GLTFLoader2.RegisterExtension(NAME15, (loader) => new KHR_materials_variants(loader));

// node_modules/@babylonjs/loaders/glTF/2.0/Extensions/KHR_materials_transmission.js
var TransmissionHelper = class {
  constructor(options, scene) {
    this._opaqueRenderTarget = null;
    this._opaqueMeshesCache = [];
    this._transparentMeshesCache = [];
    this._materialObservers = {};
    this._options = {
      ...TransmissionHelper._GetDefaultOptions(),
      ...options
    };
    this._scene = scene;
    this._scene._transmissionHelper = this;
    this.onErrorObservable = new Observable();
    this._scene.onDisposeObservable.addOnce(() => {
      this.dispose();
    });
    this._parseScene();
    this._setupRenderTargets();
  }
  static _GetDefaultOptions() {
    return {
      renderSize: 1024,
      samples: 4,
      lodGenerationScale: 1,
      lodGenerationOffset: -4,
      renderTargetTextureType: Constants.TEXTURETYPE_HALF_FLOAT,
      generateMipmaps: true
    };
  }
  updateOptions(options) {
    const newValues = Object.keys(options).filter((key) => this._options[key] !== options[key]);
    if (!newValues.length) {
      return;
    }
    const newOptions = {
      ...this._options,
      ...options
    };
    const oldOptions = this._options;
    this._options = newOptions;
    if (newOptions.renderSize !== oldOptions.renderSize || newOptions.renderTargetTextureType !== oldOptions.renderTargetTextureType || newOptions.generateMipmaps !== oldOptions.generateMipmaps || !this._opaqueRenderTarget) {
      this._setupRenderTargets();
    } else {
      this._opaqueRenderTarget.samples = newOptions.samples;
      this._opaqueRenderTarget.lodGenerationScale = newOptions.lodGenerationScale;
      this._opaqueRenderTarget.lodGenerationOffset = newOptions.lodGenerationOffset;
    }
  }
  getOpaqueTarget() {
    return this._opaqueRenderTarget;
  }
  _shouldRenderAsTransmission(material) {
    if (!material) {
      return false;
    }
    if (material instanceof PBRMaterial && material.subSurface.isRefractionEnabled) {
      return true;
    }
    return false;
  }
  _addMesh(mesh) {
    this._materialObservers[mesh.uniqueId] = mesh.onMaterialChangedObservable.add(this._onMeshMaterialChanged.bind(this));
    Tools.SetImmediate(() => {
      if (this._shouldRenderAsTransmission(mesh.material)) {
        mesh.material.refractionTexture = this._opaqueRenderTarget;
        this._transparentMeshesCache.push(mesh);
      } else {
        this._opaqueMeshesCache.push(mesh);
      }
    });
  }
  _removeMesh(mesh) {
    mesh.onMaterialChangedObservable.remove(this._materialObservers[mesh.uniqueId]);
    delete this._materialObservers[mesh.uniqueId];
    let idx = this._transparentMeshesCache.indexOf(mesh);
    if (idx !== -1) {
      this._transparentMeshesCache.splice(idx, 1);
    }
    idx = this._opaqueMeshesCache.indexOf(mesh);
    if (idx !== -1) {
      this._opaqueMeshesCache.splice(idx, 1);
    }
  }
  _parseScene() {
    this._scene.meshes.forEach(this._addMesh.bind(this));
    this._scene.onNewMeshAddedObservable.add(this._addMesh.bind(this));
    this._scene.onMeshRemovedObservable.add(this._removeMesh.bind(this));
  }
  _onMeshMaterialChanged(mesh) {
    const transparentIdx = this._transparentMeshesCache.indexOf(mesh);
    const opaqueIdx = this._opaqueMeshesCache.indexOf(mesh);
    const useTransmission = this._shouldRenderAsTransmission(mesh.material);
    if (useTransmission) {
      if (mesh.material instanceof PBRMaterial) {
        mesh.material.subSurface.refractionTexture = this._opaqueRenderTarget;
      }
      if (opaqueIdx !== -1) {
        this._opaqueMeshesCache.splice(opaqueIdx, 1);
        this._transparentMeshesCache.push(mesh);
      } else if (transparentIdx === -1) {
        this._transparentMeshesCache.push(mesh);
      }
    } else {
      if (transparentIdx !== -1) {
        this._transparentMeshesCache.splice(transparentIdx, 1);
        this._opaqueMeshesCache.push(mesh);
      } else if (opaqueIdx === -1) {
        this._opaqueMeshesCache.push(mesh);
      }
    }
  }
  _setupRenderTargets() {
    var _a, _b;
    if (this._opaqueRenderTarget) {
      this._opaqueRenderTarget.dispose();
    }
    this._opaqueRenderTarget = new RenderTargetTexture("opaqueSceneTexture", this._options.renderSize, this._scene, this._options.generateMipmaps, void 0, this._options.renderTargetTextureType);
    this._opaqueRenderTarget.ignoreCameraViewport = true;
    this._opaqueRenderTarget.renderList = this._opaqueMeshesCache;
    this._opaqueRenderTarget.clearColor = (_b = (_a = this._options.clearColor) === null || _a === void 0 ? void 0 : _a.clone()) !== null && _b !== void 0 ? _b : this._scene.clearColor.clone();
    this._opaqueRenderTarget.gammaSpace = false;
    this._opaqueRenderTarget.lodGenerationScale = this._options.lodGenerationScale;
    this._opaqueRenderTarget.lodGenerationOffset = this._options.lodGenerationOffset;
    this._opaqueRenderTarget.samples = this._options.samples;
    let sceneImageProcessingapplyByPostProcess;
    let saveSceneEnvIntensity;
    this._opaqueRenderTarget.onBeforeBindObservable.add((opaqueRenderTarget) => {
      saveSceneEnvIntensity = this._scene.environmentIntensity;
      this._scene.environmentIntensity = 1;
      sceneImageProcessingapplyByPostProcess = this._scene.imageProcessingConfiguration.applyByPostProcess;
      if (!this._options.clearColor) {
        this._scene.clearColor.toLinearSpaceToRef(opaqueRenderTarget.clearColor);
      } else {
        opaqueRenderTarget.clearColor.copyFrom(this._options.clearColor);
      }
      this._scene.imageProcessingConfiguration._applyByPostProcess = true;
    });
    this._opaqueRenderTarget.onAfterUnbindObservable.add(() => {
      this._scene.environmentIntensity = saveSceneEnvIntensity;
      this._scene.imageProcessingConfiguration._applyByPostProcess = sceneImageProcessingapplyByPostProcess;
    });
    this._transparentMeshesCache.forEach((mesh) => {
      if (this._shouldRenderAsTransmission(mesh.material)) {
        mesh.material.refractionTexture = this._opaqueRenderTarget;
      }
    });
  }
  dispose() {
    this._scene._transmissionHelper = void 0;
    if (this._opaqueRenderTarget) {
      this._opaqueRenderTarget.dispose();
      this._opaqueRenderTarget = null;
    }
    this._transparentMeshesCache = [];
    this._opaqueMeshesCache = [];
  }
};
var NAME16 = "KHR_materials_transmission";
var KHR_materials_transmission = class {
  constructor(loader) {
    this.name = NAME16;
    this.order = 175;
    this._loader = loader;
    this.enabled = this._loader.isExtensionUsed(NAME16);
    if (this.enabled) {
      loader.parent.transparencyAsCoverage = true;
    }
  }
  dispose() {
    this._loader = null;
  }
  loadMaterialPropertiesAsync(context, material, babylonMaterial) {
    return GLTFLoader2.LoadExtensionAsync(context, material, this.name, (extensionContext, extension) => {
      const promises = new Array();
      promises.push(this._loader.loadMaterialBasePropertiesAsync(context, material, babylonMaterial));
      promises.push(this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));
      promises.push(this._loadTransparentPropertiesAsync(extensionContext, material, babylonMaterial, extension));
      return Promise.all(promises).then(() => {
      });
    });
  }
  _loadTransparentPropertiesAsync(context, material, babylonMaterial, extension) {
    if (!(babylonMaterial instanceof PBRMaterial)) {
      throw new Error(`${context}: Material type not supported`);
    }
    const pbrMaterial = babylonMaterial;
    pbrMaterial.subSurface.isRefractionEnabled = true;
    pbrMaterial.subSurface.volumeIndexOfRefraction = 1;
    pbrMaterial.subSurface.useAlbedoToTintRefraction = true;
    if (extension.transmissionFactor !== void 0) {
      pbrMaterial.subSurface.refractionIntensity = extension.transmissionFactor;
      const scene = pbrMaterial.getScene();
      if (pbrMaterial.subSurface.refractionIntensity && !scene._transmissionHelper) {
        new TransmissionHelper({}, pbrMaterial.getScene());
      }
    } else {
      pbrMaterial.subSurface.refractionIntensity = 0;
      pbrMaterial.subSurface.isRefractionEnabled = false;
      return Promise.resolve();
    }
    pbrMaterial.subSurface.minimumThickness = 0;
    pbrMaterial.subSurface.maximumThickness = 0;
    if (extension.transmissionTexture) {
      extension.transmissionTexture.nonColorData = true;
      return this._loader.loadTextureInfoAsync(`${context}/transmissionTexture`, extension.transmissionTexture, void 0).then((texture) => {
        pbrMaterial.subSurface.refractionIntensityTexture = texture;
        pbrMaterial.subSurface.useGltfStyleTextures = true;
      });
    } else {
      return Promise.resolve();
    }
  }
};
GLTFLoader2.RegisterExtension(NAME16, (loader) => new KHR_materials_transmission(loader));

// node_modules/@babylonjs/loaders/glTF/2.0/Extensions/KHR_materials_translucency.js
var NAME17 = "KHR_materials_translucency";
var KHR_materials_translucency = class {
  constructor(loader) {
    this.name = NAME17;
    this.order = 174;
    this._loader = loader;
    this.enabled = this._loader.isExtensionUsed(NAME17);
    if (this.enabled) {
      loader.parent.transparencyAsCoverage = true;
    }
  }
  dispose() {
    this._loader = null;
  }
  loadMaterialPropertiesAsync(context, material, babylonMaterial) {
    return GLTFLoader2.LoadExtensionAsync(context, material, this.name, (extensionContext, extension) => {
      const promises = new Array();
      promises.push(this._loader.loadMaterialBasePropertiesAsync(context, material, babylonMaterial));
      promises.push(this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));
      promises.push(this._loadTranslucentPropertiesAsync(extensionContext, material, babylonMaterial, extension));
      return Promise.all(promises).then(() => {
      });
    });
  }
  _loadTranslucentPropertiesAsync(context, material, babylonMaterial, extension) {
    if (!(babylonMaterial instanceof PBRMaterial)) {
      throw new Error(`${context}: Material type not supported`);
    }
    const pbrMaterial = babylonMaterial;
    pbrMaterial.subSurface.isTranslucencyEnabled = true;
    pbrMaterial.subSurface.volumeIndexOfRefraction = 1;
    pbrMaterial.subSurface.minimumThickness = 0;
    pbrMaterial.subSurface.maximumThickness = 0;
    pbrMaterial.subSurface.useAlbedoToTintTranslucency = true;
    if (extension.translucencyFactor !== void 0) {
      pbrMaterial.subSurface.translucencyIntensity = extension.translucencyFactor;
    } else {
      pbrMaterial.subSurface.translucencyIntensity = 0;
      pbrMaterial.subSurface.isTranslucencyEnabled = false;
      return Promise.resolve();
    }
    if (extension.translucencyTexture) {
      extension.translucencyTexture.nonColorData = true;
      return this._loader.loadTextureInfoAsync(`${context}/translucencyTexture`, extension.translucencyTexture).then((texture) => {
        pbrMaterial.subSurface.translucencyIntensityTexture = texture;
      });
    } else {
      return Promise.resolve();
    }
  }
};
GLTFLoader2.RegisterExtension(NAME17, (loader) => new KHR_materials_translucency(loader));

// node_modules/@babylonjs/loaders/glTF/2.0/Extensions/KHR_materials_volume.js
var NAME18 = "KHR_materials_volume";
var KHR_materials_volume = class {
  constructor(loader) {
    this.name = NAME18;
    this.order = 173;
    this._loader = loader;
    this.enabled = this._loader.isExtensionUsed(NAME18);
    if (this.enabled) {
      this._loader._disableInstancedMesh++;
    }
  }
  dispose() {
    if (this.enabled) {
      this._loader._disableInstancedMesh--;
    }
    this._loader = null;
  }
  loadMaterialPropertiesAsync(context, material, babylonMaterial) {
    return GLTFLoader2.LoadExtensionAsync(context, material, this.name, (extensionContext, extension) => {
      const promises = new Array();
      promises.push(this._loader.loadMaterialBasePropertiesAsync(context, material, babylonMaterial));
      promises.push(this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));
      promises.push(this._loadVolumePropertiesAsync(extensionContext, material, babylonMaterial, extension));
      return Promise.all(promises).then(() => {
      });
    });
  }
  _loadVolumePropertiesAsync(context, material, babylonMaterial, extension) {
    if (!(babylonMaterial instanceof PBRMaterial)) {
      throw new Error(`${context}: Material type not supported`);
    }
    if (!babylonMaterial.subSurface.isRefractionEnabled && !babylonMaterial.subSurface.isTranslucencyEnabled || !extension.thicknessFactor) {
      return Promise.resolve();
    }
    babylonMaterial.subSurface.volumeIndexOfRefraction = babylonMaterial.indexOfRefraction;
    const attenuationDistance = extension.attenuationDistance !== void 0 ? extension.attenuationDistance : Number.MAX_VALUE;
    babylonMaterial.subSurface.tintColorAtDistance = attenuationDistance;
    if (extension.attenuationColor !== void 0 && extension.attenuationColor.length == 3) {
      babylonMaterial.subSurface.tintColor.copyFromFloats(extension.attenuationColor[0], extension.attenuationColor[1], extension.attenuationColor[2]);
    }
    babylonMaterial.subSurface.minimumThickness = 0;
    babylonMaterial.subSurface.maximumThickness = extension.thicknessFactor;
    babylonMaterial.subSurface.useThicknessAsDepth = true;
    if (extension.thicknessTexture) {
      extension.thicknessTexture.nonColorData = true;
      return this._loader.loadTextureInfoAsync(`${context}/thicknessTexture`, extension.thicknessTexture).then((texture) => {
        babylonMaterial.subSurface.thicknessTexture = texture;
        babylonMaterial.subSurface.useGltfStyleTextures = true;
      });
    } else {
      return Promise.resolve();
    }
  }
};
GLTFLoader2.RegisterExtension(NAME18, (loader) => new KHR_materials_volume(loader));

// node_modules/@babylonjs/loaders/glTF/2.0/Extensions/KHR_mesh_quantization.js
var NAME19 = "KHR_mesh_quantization";
var KHR_mesh_quantization = class {
  constructor(loader) {
    this.name = NAME19;
    this.enabled = loader.isExtensionUsed(NAME19);
  }
  dispose() {
  }
};
GLTFLoader2.RegisterExtension(NAME19, (loader) => new KHR_mesh_quantization(loader));

// node_modules/@babylonjs/loaders/glTF/2.0/Extensions/KHR_texture_basisu.js
var NAME20 = "KHR_texture_basisu";
var KHR_texture_basisu = class {
  constructor(loader) {
    this.name = NAME20;
    this._loader = loader;
    this.enabled = loader.isExtensionUsed(NAME20);
  }
  dispose() {
    this._loader = null;
  }
  _loadTextureAsync(context, texture, assign) {
    return GLTFLoader2.LoadExtensionAsync(context, texture, this.name, (extensionContext, extension) => {
      const sampler = texture.sampler == void 0 ? GLTFLoader2.DefaultSampler : ArrayItem.Get(`${context}/sampler`, this._loader.gltf.samplers, texture.sampler);
      const image = ArrayItem.Get(`${extensionContext}/source`, this._loader.gltf.images, extension.source);
      return this._loader._createTextureAsync(context, sampler, image, (babylonTexture) => {
        assign(babylonTexture);
      }, texture._textureInfo.nonColorData ? { useRGBAIfASTCBC7NotAvailableWhenUASTC: true } : void 0, !texture._textureInfo.nonColorData);
    });
  }
};
GLTFLoader2.RegisterExtension(NAME20, (loader) => new KHR_texture_basisu(loader));

// node_modules/@babylonjs/loaders/glTF/2.0/Extensions/KHR_texture_transform.js
var NAME21 = "KHR_texture_transform";
var KHR_texture_transform = class {
  constructor(loader) {
    this.name = NAME21;
    this._loader = loader;
    this.enabled = this._loader.isExtensionUsed(NAME21);
  }
  dispose() {
    this._loader = null;
  }
  loadTextureInfoAsync(context, textureInfo, assign) {
    return GLTFLoader2.LoadExtensionAsync(context, textureInfo, this.name, (extensionContext, extension) => {
      return this._loader.loadTextureInfoAsync(context, textureInfo, (babylonTexture) => {
        if (!(babylonTexture instanceof Texture)) {
          throw new Error(`${extensionContext}: Texture type not supported`);
        }
        if (extension.offset) {
          babylonTexture.uOffset = extension.offset[0];
          babylonTexture.vOffset = extension.offset[1];
        }
        babylonTexture.uRotationCenter = 0;
        babylonTexture.vRotationCenter = 0;
        if (extension.rotation) {
          babylonTexture.wAng = -extension.rotation;
        }
        if (extension.scale) {
          babylonTexture.uScale = extension.scale[0];
          babylonTexture.vScale = extension.scale[1];
        }
        if (extension.texCoord != void 0) {
          babylonTexture.coordinatesIndex = extension.texCoord;
        }
        assign(babylonTexture);
      });
    });
  }
};
GLTFLoader2.RegisterExtension(NAME21, (loader) => new KHR_texture_transform(loader));

// node_modules/@babylonjs/loaders/glTF/2.0/Extensions/KHR_xmp_json_ld.js
var NAME22 = "KHR_xmp_json_ld";
var KHR_xmp_json_ld = class {
  constructor(loader) {
    this.name = NAME22;
    this.order = 100;
    this._loader = loader;
    this.enabled = this._loader.isExtensionUsed(NAME22);
  }
  dispose() {
    this._loader = null;
  }
  onLoading() {
    var _a, _b, _c;
    if (this._loader.rootBabylonMesh === null) {
      return;
    }
    const xmp_gltf = (_a = this._loader.gltf.extensions) === null || _a === void 0 ? void 0 : _a.KHR_xmp_json_ld;
    const xmp_node = (_c = (_b = this._loader.gltf.asset) === null || _b === void 0 ? void 0 : _b.extensions) === null || _c === void 0 ? void 0 : _c.KHR_xmp_json_ld;
    if (xmp_gltf && xmp_node) {
      const packet = +xmp_node.packet;
      if (xmp_gltf.packets && packet < xmp_gltf.packets.length) {
        this._loader.rootBabylonMesh.metadata = this._loader.rootBabylonMesh.metadata || {};
        this._loader.rootBabylonMesh.metadata.xmp = xmp_gltf.packets[packet];
      }
    }
  }
};
GLTFLoader2.RegisterExtension(NAME22, (loader) => new KHR_xmp_json_ld(loader));

// node_modules/@babylonjs/loaders/glTF/2.0/Extensions/KHR_animation_pointer.data.js
function getColor3(_target, source, offset, scale) {
  return Color3.FromArray(source, offset).scale(scale);
}
function getAlpha(_target, source, offset, scale) {
  return source[offset + 3] * scale;
}
function getFloat(_target, source, offset, scale) {
  return source[offset] * scale;
}
function getMinusFloat(_target, source, offset, scale) {
  return -source[offset] * scale;
}
function getNextFloat(_target, source, offset, scale) {
  return source[offset + 1] * scale;
}
function getFloatBy2(_target, source, offset, scale) {
  return source[offset] * scale * 2;
}
function getTextureTransformTree(textureName) {
  return {
    scale: [
      new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, `${textureName}.uScale`, getFloat, () => 2),
      new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, `${textureName}.vScale`, getNextFloat, () => 2)
    ],
    offset: [
      new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, `${textureName}.uOffset`, getFloat, () => 2),
      new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, `${textureName}.vOffset`, getNextFloat, () => 2)
    ],
    rotation: [new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, `${textureName}.wAng`, getMinusFloat, () => 1)]
  };
}
var CameraAnimationPropertyInfo = class extends AnimationPropertyInfo {
  buildAnimations(target, name, fps, keys, callback) {
    callback(target._babylonCamera, this._buildAnimation(name, fps, keys));
  }
};
var MaterialAnimationPropertyInfo = class extends AnimationPropertyInfo {
  buildAnimations(target, name, fps, keys, callback) {
    for (const fillMode in target._data) {
      callback(target._data[fillMode].babylonMaterial, this._buildAnimation(name, fps, keys));
    }
  }
};
var LightAnimationPropertyInfo = class extends AnimationPropertyInfo {
  buildAnimations(target, name, fps, keys, callback) {
    callback(target._babylonLight, this._buildAnimation(name, fps, keys));
  }
};
var nodesTree = {
  __array__: {
    __target__: true,
    ...nodeAnimationData
  }
};
var camerasTree = {
  __array__: {
    __target__: true,
    orthographic: {
      xmag: [
        new CameraAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, "orthoLeft", getMinusFloat, () => 1),
        new CameraAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, "orthoRight", getNextFloat, () => 1)
      ],
      ymag: [
        new CameraAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, "orthoBottom", getMinusFloat, () => 1),
        new CameraAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, "orthoTop", getNextFloat, () => 1)
      ],
      zfar: [new CameraAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, "maxZ", getFloat, () => 1)],
      znear: [new CameraAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, "minZ", getFloat, () => 1)]
    },
    perspective: {
      yfov: [new CameraAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, "fov", getFloat, () => 1)],
      zfar: [new CameraAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, "maxZ", getFloat, () => 1)],
      znear: [new CameraAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, "minZ", getFloat, () => 1)]
    }
  }
};
var materialsTree = {
  __array__: {
    __target__: true,
    pbrMetallicRoughness: {
      baseColorFactor: [
        new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_COLOR3, "albedoColor", getColor3, () => 4),
        new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, "alpha", getAlpha, () => 4)
      ],
      metallicFactor: [new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, "metallic", getFloat, () => 1)],
      roughnessFactor: [new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, "roughness", getFloat, () => 1)],
      baseColorTexture: {
        extensions: {
          KHR_texture_transform: getTextureTransformTree("albedoTexture")
        }
      }
    },
    emissiveFactor: [new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_COLOR3, "emissiveColor", getColor3, () => 3)],
    normalTexture: {
      scale: [new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, "bumpTexture.level", getFloat, () => 1)]
    },
    occlusionTexture: {
      strength: [new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, "ambientTextureStrength", getFloat, () => 1)],
      extensions: {
        KHR_texture_transform: getTextureTransformTree("ambientTexture")
      }
    },
    emissiveTexture: {
      extensions: {
        KHR_texture_transform: getTextureTransformTree("emissiveTexture")
      }
    },
    extensions: {
      KHR_materials_ior: {
        ior: [new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, "indexOfRefraction", getFloat, () => 1)]
      },
      KHR_materials_clearcoat: {
        clearcoatFactor: [new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, "clearCoat.intensity", getFloat, () => 1)],
        clearcoatRoughnessFactor: [new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, "clearCoat.roughness", getFloat, () => 1)]
      },
      KHR_materials_sheen: {
        sheenColorFactor: [new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_COLOR3, "sheen.color", getColor3, () => 3)],
        sheenRoughnessFactor: [new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, "sheen.roughness", getFloat, () => 1)]
      },
      KHR_materials_specular: {
        specularFactor: [new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, "metallicF0Factor", getFloat, () => 1)],
        specularColorFactor: [new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_COLOR3, "metallicReflectanceColor", getColor3, () => 3)]
      },
      KHR_materials_emissive_strength: {
        emissiveStrength: [new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, "emissiveIntensity", getFloat, () => 1)]
      },
      KHR_materials_transmission: {
        transmissionFactor: [new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, "subSurface.refractionIntensity", getFloat, () => 1)]
      },
      KHR_materials_volume: {
        attenuationColor: [new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_COLOR3, "subSurface.tintColor", getColor3, () => 3)],
        attenuationDistance: [new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, "subSurface.tintColorAtDistance", getFloat, () => 1)],
        thicknessFactor: [new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, "subSurface.maximumThickness", getFloat, () => 1)]
      },
      KHR_materials_iridescence: {
        iridescenceFactor: [new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, "iridescence.intensity", getFloat, () => 1)],
        iridescenceIor: [new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, "iridescence.indexOfRefraction", getFloat, () => 1)],
        iridescenceThicknessMinimum: [new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, "iridescence.minimumThickness", getFloat, () => 1)],
        iridescenceThicknessMaximum: [new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, "iridescence.maximumThickness", getFloat, () => 1)]
      }
    }
  }
};
var extensionsTree = {
  KHR_lights_punctual: {
    lights: {
      __array__: {
        __target__: true,
        color: [new LightAnimationPropertyInfo(Animation.ANIMATIONTYPE_COLOR3, "diffuse", getColor3, () => 3)],
        intensity: [new LightAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, "intensity", getFloat, () => 1)],
        range: [new LightAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, "range", getFloat, () => 1)],
        spot: {
          innerConeAngle: [new LightAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, "innerAngle", getFloatBy2, () => 1)],
          outerConeAngle: [new LightAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, "angle", getFloatBy2, () => 1)]
        }
      }
    }
  }
};
var animationPointerTree = {
  nodes: nodesTree,
  materials: materialsTree,
  cameras: camerasTree,
  extensions: extensionsTree
};

// node_modules/@babylonjs/loaders/glTF/2.0/Extensions/KHR_animation_pointer.js
var NAME23 = "KHR_animation_pointer";
var KHR_animation_pointer = class {
  constructor(loader) {
    this.name = NAME23;
    this._loader = loader;
  }
  get enabled() {
    return this._loader.isExtensionUsed(NAME23);
  }
  dispose() {
    this._loader = null;
  }
  _loadAnimationChannelAsync(context, animationContext, animation, channel, onLoad) {
    var _a;
    const extension = (_a = channel.target.extensions) === null || _a === void 0 ? void 0 : _a.KHR_animation_pointer;
    if (!extension) {
      return null;
    }
    if (channel.target.path !== "pointer") {
      Logger.Warn(`${context}/target/path: Value (${channel.target.path}) must be (${"pointer"}) when using the ${this.name} extension`);
    }
    if (channel.target.node != void 0) {
      Logger.Warn(`${context}/target/node: Value (${channel.target.node}) must not be present when using the ${this.name} extension`);
    }
    const extensionContext = `${context}/extensions/${this.name}`;
    const pointer = extension.pointer;
    if (!pointer) {
      throw new Error(`${extensionContext}: Pointer is missing`);
    }
    const targetInfo = this._parseAnimationPointer(`${extensionContext}/pointer`, pointer);
    if (!targetInfo) {
      Logger.Warn(`${extensionContext}/pointer: Invalid pointer (${pointer}) skipped`);
      return null;
    }
    return this._loader._loadAnimationChannelFromTargetInfoAsync(context, animationContext, animation, channel, targetInfo, onLoad);
  }
  _parseAnimationPointer(context, pointer) {
    if (!pointer.startsWith("/")) {
      Logger.Warn(`${context}: Value (${pointer}) must start with a slash`);
      return null;
    }
    const parts = pointer.split("/");
    parts.shift();
    let node = animationPointerTree;
    let gltfCurrentNode = this._loader.gltf;
    let gltfTargetNode = void 0;
    for (const part of parts) {
      if (node.__array__) {
        node = node.__array__;
      } else {
        node = node[part];
        if (!node) {
          return null;
        }
      }
      gltfCurrentNode = gltfCurrentNode && gltfCurrentNode[part];
      if (node.__target__) {
        gltfTargetNode = gltfCurrentNode;
      }
    }
    if (!gltfTargetNode || !Array.isArray(node)) {
      return null;
    }
    return {
      target: gltfTargetNode,
      properties: node
    };
  }
};
GLTFLoader2.RegisterExtension(NAME23, (loader) => new KHR_animation_pointer(loader));

// node_modules/@babylonjs/loaders/glTF/2.0/Extensions/MSFT_audio_emitter.js
var NAME24 = "MSFT_audio_emitter";
var MSFT_audio_emitter = class {
  constructor(loader) {
    this.name = NAME24;
    this._loader = loader;
    this.enabled = this._loader.isExtensionUsed(NAME24);
  }
  dispose() {
    this._loader = null;
    this._clips = null;
    this._emitters = null;
  }
  onLoading() {
    const extensions = this._loader.gltf.extensions;
    if (extensions && extensions[this.name]) {
      const extension = extensions[this.name];
      this._clips = extension.clips;
      this._emitters = extension.emitters;
      ArrayItem.Assign(this._clips);
      ArrayItem.Assign(this._emitters);
    }
  }
  loadSceneAsync(context, scene) {
    return GLTFLoader2.LoadExtensionAsync(context, scene, this.name, (extensionContext, extension) => {
      const promises = new Array();
      promises.push(this._loader.loadSceneAsync(context, scene));
      for (const emitterIndex of extension.emitters) {
        const emitter = ArrayItem.Get(`${extensionContext}/emitters`, this._emitters, emitterIndex);
        if (emitter.refDistance != void 0 || emitter.maxDistance != void 0 || emitter.rolloffFactor != void 0 || emitter.distanceModel != void 0 || emitter.innerAngle != void 0 || emitter.outerAngle != void 0) {
          throw new Error(`${extensionContext}: Direction or Distance properties are not allowed on emitters attached to a scene`);
        }
        promises.push(this._loadEmitterAsync(`${extensionContext}/emitters/${emitter.index}`, emitter));
      }
      return Promise.all(promises).then(() => {
      });
    });
  }
  loadNodeAsync(context, node, assign) {
    return GLTFLoader2.LoadExtensionAsync(context, node, this.name, (extensionContext, extension) => {
      const promises = new Array();
      return this._loader.loadNodeAsync(extensionContext, node, (babylonMesh) => {
        for (const emitterIndex of extension.emitters) {
          const emitter = ArrayItem.Get(`${extensionContext}/emitters`, this._emitters, emitterIndex);
          promises.push(this._loadEmitterAsync(`${extensionContext}/emitters/${emitter.index}`, emitter).then(() => {
            for (const sound of emitter._babylonSounds) {
              sound.attachToMesh(babylonMesh);
              if (emitter.innerAngle != void 0 || emitter.outerAngle != void 0) {
                sound.setLocalDirectionToMesh(Vector3.Forward());
                sound.setDirectionalCone(2 * Tools.ToDegrees(emitter.innerAngle == void 0 ? Math.PI : emitter.innerAngle), 2 * Tools.ToDegrees(emitter.outerAngle == void 0 ? Math.PI : emitter.outerAngle), 0);
              }
            }
          }));
        }
        assign(babylonMesh);
      }).then((babylonMesh) => {
        return Promise.all(promises).then(() => {
          return babylonMesh;
        });
      });
    });
  }
  loadAnimationAsync(context, animation) {
    return GLTFLoader2.LoadExtensionAsync(context, animation, this.name, (extensionContext, extension) => {
      return this._loader.loadAnimationAsync(context, animation).then((babylonAnimationGroup) => {
        const promises = new Array();
        ArrayItem.Assign(extension.events);
        for (const event of extension.events) {
          promises.push(this._loadAnimationEventAsync(`${extensionContext}/events/${event.index}`, context, animation, event, babylonAnimationGroup));
        }
        return Promise.all(promises).then(() => {
          return babylonAnimationGroup;
        });
      });
    });
  }
  _loadClipAsync(context, clip) {
    if (clip._objectURL) {
      return clip._objectURL;
    }
    let promise;
    if (clip.uri) {
      promise = this._loader.loadUriAsync(context, clip, clip.uri);
    } else {
      const bufferView = ArrayItem.Get(`${context}/bufferView`, this._loader.gltf.bufferViews, clip.bufferView);
      promise = this._loader.loadBufferViewAsync(`/bufferViews/${bufferView.index}`, bufferView);
    }
    clip._objectURL = promise.then((data) => {
      return URL.createObjectURL(new Blob([data], { type: clip.mimeType }));
    });
    return clip._objectURL;
  }
  _loadEmitterAsync(context, emitter) {
    emitter._babylonSounds = emitter._babylonSounds || [];
    if (!emitter._babylonData) {
      const clipPromises = new Array();
      const name = emitter.name || `emitter${emitter.index}`;
      const options = {
        loop: false,
        autoplay: false,
        volume: emitter.volume == void 0 ? 1 : emitter.volume
      };
      for (let i = 0; i < emitter.clips.length; i++) {
        const clipContext = `/extensions/${this.name}/clips`;
        const clip = ArrayItem.Get(clipContext, this._clips, emitter.clips[i].clip);
        clipPromises.push(this._loadClipAsync(`${clipContext}/${emitter.clips[i].clip}`, clip).then((objectURL) => {
          const sound = emitter._babylonSounds[i] = new Sound(name, objectURL, this._loader.babylonScene, null, options);
          sound.refDistance = emitter.refDistance || 1;
          sound.maxDistance = emitter.maxDistance || 256;
          sound.rolloffFactor = emitter.rolloffFactor || 1;
          sound.distanceModel = emitter.distanceModel || "exponential";
        }));
      }
      const promise = Promise.all(clipPromises).then(() => {
        const weights = emitter.clips.map((clip) => {
          return clip.weight || 1;
        });
        const weightedSound = new WeightedSound(emitter.loop || false, emitter._babylonSounds, weights);
        if (emitter.innerAngle) {
          weightedSound.directionalConeInnerAngle = 2 * Tools.ToDegrees(emitter.innerAngle);
        }
        if (emitter.outerAngle) {
          weightedSound.directionalConeOuterAngle = 2 * Tools.ToDegrees(emitter.outerAngle);
        }
        if (emitter.volume) {
          weightedSound.volume = emitter.volume;
        }
        emitter._babylonData.sound = weightedSound;
      });
      emitter._babylonData = {
        loaded: promise
      };
    }
    return emitter._babylonData.loaded;
  }
  _getEventAction(context, sound, action, time, startOffset) {
    switch (action) {
      case "play": {
        return (currentFrame) => {
          const frameOffset = (startOffset || 0) + (currentFrame - time);
          sound.play(frameOffset);
        };
      }
      case "stop": {
        return () => {
          sound.stop();
        };
      }
      case "pause": {
        return () => {
          sound.pause();
        };
      }
      default: {
        throw new Error(`${context}: Unsupported action ${action}`);
      }
    }
  }
  _loadAnimationEventAsync(context, animationContext, animation, event, babylonAnimationGroup) {
    if (babylonAnimationGroup.targetedAnimations.length == 0) {
      return Promise.resolve();
    }
    const babylonAnimation = babylonAnimationGroup.targetedAnimations[0];
    const emitterIndex = event.emitter;
    const emitter = ArrayItem.Get(`/extensions/${this.name}/emitters`, this._emitters, emitterIndex);
    return this._loadEmitterAsync(context, emitter).then(() => {
      const sound = emitter._babylonData.sound;
      if (sound) {
        const babylonAnimationEvent = new AnimationEvent(event.time, this._getEventAction(context, sound, event.action, event.time, event.startOffset));
        babylonAnimation.animation.addEvent(babylonAnimationEvent);
        babylonAnimationGroup.onAnimationGroupEndObservable.add(() => {
          sound.stop();
        });
        babylonAnimationGroup.onAnimationGroupPauseObservable.add(() => {
          sound.pause();
        });
      }
    });
  }
};
GLTFLoader2.RegisterExtension(NAME24, (loader) => new MSFT_audio_emitter(loader));

// node_modules/@babylonjs/loaders/glTF/2.0/Extensions/MSFT_lod.js
var NAME25 = "MSFT_lod";
var MSFT_lod = class {
  constructor(loader) {
    this.name = NAME25;
    this.order = 100;
    this.maxLODsToLoad = 10;
    this.onNodeLODsLoadedObservable = new Observable();
    this.onMaterialLODsLoadedObservable = new Observable();
    this._bufferLODs = new Array();
    this._nodeIndexLOD = null;
    this._nodeSignalLODs = new Array();
    this._nodePromiseLODs = new Array();
    this._nodeBufferLODs = new Array();
    this._materialIndexLOD = null;
    this._materialSignalLODs = new Array();
    this._materialPromiseLODs = new Array();
    this._materialBufferLODs = new Array();
    this._loader = loader;
    this.enabled = this._loader.isExtensionUsed(NAME25);
  }
  dispose() {
    this._loader = null;
    this._nodeIndexLOD = null;
    this._nodeSignalLODs.length = 0;
    this._nodePromiseLODs.length = 0;
    this._nodeBufferLODs.length = 0;
    this._materialIndexLOD = null;
    this._materialSignalLODs.length = 0;
    this._materialPromiseLODs.length = 0;
    this._materialBufferLODs.length = 0;
    this.onMaterialLODsLoadedObservable.clear();
    this.onNodeLODsLoadedObservable.clear();
  }
  onReady() {
    for (let indexLOD = 0; indexLOD < this._nodePromiseLODs.length; indexLOD++) {
      const promise = Promise.all(this._nodePromiseLODs[indexLOD]).then(() => {
        if (indexLOD !== 0) {
          this._loader.endPerformanceCounter(`Node LOD ${indexLOD}`);
          this._loader.log(`Loaded node LOD ${indexLOD}`);
        }
        this.onNodeLODsLoadedObservable.notifyObservers(indexLOD);
        if (indexLOD !== this._nodePromiseLODs.length - 1) {
          this._loader.startPerformanceCounter(`Node LOD ${indexLOD + 1}`);
          this._loadBufferLOD(this._nodeBufferLODs, indexLOD + 1);
          if (this._nodeSignalLODs[indexLOD]) {
            this._nodeSignalLODs[indexLOD].resolve();
          }
        }
      });
      this._loader._completePromises.push(promise);
    }
    for (let indexLOD = 0; indexLOD < this._materialPromiseLODs.length; indexLOD++) {
      const promise = Promise.all(this._materialPromiseLODs[indexLOD]).then(() => {
        if (indexLOD !== 0) {
          this._loader.endPerformanceCounter(`Material LOD ${indexLOD}`);
          this._loader.log(`Loaded material LOD ${indexLOD}`);
        }
        this.onMaterialLODsLoadedObservable.notifyObservers(indexLOD);
        if (indexLOD !== this._materialPromiseLODs.length - 1) {
          this._loader.startPerformanceCounter(`Material LOD ${indexLOD + 1}`);
          this._loadBufferLOD(this._materialBufferLODs, indexLOD + 1);
          if (this._materialSignalLODs[indexLOD]) {
            this._materialSignalLODs[indexLOD].resolve();
          }
        }
      });
      this._loader._completePromises.push(promise);
    }
  }
  loadSceneAsync(context, scene) {
    const promise = this._loader.loadSceneAsync(context, scene);
    this._loadBufferLOD(this._bufferLODs, 0);
    return promise;
  }
  loadNodeAsync(context, node, assign) {
    return GLTFLoader2.LoadExtensionAsync(context, node, this.name, (extensionContext, extension) => {
      let firstPromise;
      const nodeLODs = this._getLODs(extensionContext, node, this._loader.gltf.nodes, extension.ids);
      this._loader.logOpen(`${extensionContext}`);
      for (let indexLOD = 0; indexLOD < nodeLODs.length; indexLOD++) {
        const nodeLOD = nodeLODs[indexLOD];
        if (indexLOD !== 0) {
          this._nodeIndexLOD = indexLOD;
          this._nodeSignalLODs[indexLOD] = this._nodeSignalLODs[indexLOD] || new Deferred();
        }
        const assignWrap = (babylonTransformNode) => {
          assign(babylonTransformNode);
          babylonTransformNode.setEnabled(false);
        };
        const promise = this._loader.loadNodeAsync(`/nodes/${nodeLOD.index}`, nodeLOD, assignWrap).then((babylonMesh) => {
          if (indexLOD !== 0) {
            const previousNodeLOD = nodeLODs[indexLOD - 1];
            if (previousNodeLOD._babylonTransformNode) {
              this._disposeTransformNode(previousNodeLOD._babylonTransformNode);
              delete previousNodeLOD._babylonTransformNode;
            }
          }
          babylonMesh.setEnabled(true);
          return babylonMesh;
        });
        this._nodePromiseLODs[indexLOD] = this._nodePromiseLODs[indexLOD] || [];
        if (indexLOD === 0) {
          firstPromise = promise;
        } else {
          this._nodeIndexLOD = null;
          this._nodePromiseLODs[indexLOD].push(promise);
        }
      }
      this._loader.logClose();
      return firstPromise;
    });
  }
  _loadMaterialAsync(context, material, babylonMesh, babylonDrawMode, assign) {
    if (this._nodeIndexLOD) {
      return null;
    }
    return GLTFLoader2.LoadExtensionAsync(context, material, this.name, (extensionContext, extension) => {
      let firstPromise;
      const materialLODs = this._getLODs(extensionContext, material, this._loader.gltf.materials, extension.ids);
      this._loader.logOpen(`${extensionContext}`);
      for (let indexLOD = 0; indexLOD < materialLODs.length; indexLOD++) {
        const materialLOD = materialLODs[indexLOD];
        if (indexLOD !== 0) {
          this._materialIndexLOD = indexLOD;
        }
        const promise = this._loader._loadMaterialAsync(`/materials/${materialLOD.index}`, materialLOD, babylonMesh, babylonDrawMode, (babylonMaterial) => {
          if (indexLOD === 0) {
            assign(babylonMaterial);
          }
        }).then((babylonMaterial) => {
          if (indexLOD !== 0) {
            assign(babylonMaterial);
            const previousDataLOD = materialLODs[indexLOD - 1]._data;
            if (previousDataLOD[babylonDrawMode]) {
              this._disposeMaterials([previousDataLOD[babylonDrawMode].babylonMaterial]);
              delete previousDataLOD[babylonDrawMode];
            }
          }
          return babylonMaterial;
        });
        this._materialPromiseLODs[indexLOD] = this._materialPromiseLODs[indexLOD] || [];
        if (indexLOD === 0) {
          firstPromise = promise;
        } else {
          this._materialIndexLOD = null;
          this._materialPromiseLODs[indexLOD].push(promise);
        }
      }
      this._loader.logClose();
      return firstPromise;
    });
  }
  _loadUriAsync(context, property, uri) {
    if (this._nodeIndexLOD !== null) {
      this._loader.log(`deferred`);
      const previousIndexLOD = this._nodeIndexLOD - 1;
      this._nodeSignalLODs[previousIndexLOD] = this._nodeSignalLODs[previousIndexLOD] || new Deferred();
      return this._nodeSignalLODs[this._nodeIndexLOD - 1].promise.then(() => {
        return this._loader.loadUriAsync(context, property, uri);
      });
    } else if (this._materialIndexLOD !== null) {
      this._loader.log(`deferred`);
      const previousIndexLOD = this._materialIndexLOD - 1;
      this._materialSignalLODs[previousIndexLOD] = this._materialSignalLODs[previousIndexLOD] || new Deferred();
      return this._materialSignalLODs[previousIndexLOD].promise.then(() => {
        return this._loader.loadUriAsync(context, property, uri);
      });
    }
    return null;
  }
  loadBufferAsync(context, buffer, byteOffset, byteLength) {
    if (this._loader.parent.useRangeRequests && !buffer.uri) {
      if (!this._loader.bin) {
        throw new Error(`${context}: Uri is missing or the binary glTF is missing its binary chunk`);
      }
      const loadAsync = (bufferLODs, indexLOD) => {
        const start = byteOffset;
        const end = start + byteLength - 1;
        let bufferLOD = bufferLODs[indexLOD];
        if (bufferLOD) {
          bufferLOD.start = Math.min(bufferLOD.start, start);
          bufferLOD.end = Math.max(bufferLOD.end, end);
        } else {
          bufferLOD = { start, end, loaded: new Deferred() };
          bufferLODs[indexLOD] = bufferLOD;
        }
        return bufferLOD.loaded.promise.then((data) => {
          return new Uint8Array(data.buffer, data.byteOffset + byteOffset - bufferLOD.start, byteLength);
        });
      };
      this._loader.log(`deferred`);
      if (this._nodeIndexLOD !== null) {
        return loadAsync(this._nodeBufferLODs, this._nodeIndexLOD);
      } else if (this._materialIndexLOD !== null) {
        return loadAsync(this._materialBufferLODs, this._materialIndexLOD);
      } else {
        return loadAsync(this._bufferLODs, 0);
      }
    }
    return null;
  }
  _loadBufferLOD(bufferLODs, indexLOD) {
    const bufferLOD = bufferLODs[indexLOD];
    if (bufferLOD) {
      this._loader.log(`Loading buffer range [${bufferLOD.start}-${bufferLOD.end}]`);
      this._loader.bin.readAsync(bufferLOD.start, bufferLOD.end - bufferLOD.start + 1).then((data) => {
        bufferLOD.loaded.resolve(data);
      }, (error) => {
        bufferLOD.loaded.reject(error);
      });
    }
  }
  _getLODs(context, property, array, ids) {
    if (this.maxLODsToLoad <= 0) {
      throw new Error("maxLODsToLoad must be greater than zero");
    }
    const properties = new Array();
    for (let i = ids.length - 1; i >= 0; i--) {
      properties.push(ArrayItem.Get(`${context}/ids/${ids[i]}`, array, ids[i]));
      if (properties.length === this.maxLODsToLoad) {
        return properties;
      }
    }
    properties.push(property);
    return properties;
  }
  _disposeTransformNode(babylonTransformNode) {
    const babylonMaterials = new Array();
    const babylonMaterial = babylonTransformNode.material;
    if (babylonMaterial) {
      babylonMaterials.push(babylonMaterial);
    }
    for (const babylonMesh of babylonTransformNode.getChildMeshes()) {
      if (babylonMesh.material) {
        babylonMaterials.push(babylonMesh.material);
      }
    }
    babylonTransformNode.dispose();
    const babylonMaterialsToDispose = babylonMaterials.filter((babylonMaterial2) => this._loader.babylonScene.meshes.every((mesh) => mesh.material != babylonMaterial2));
    this._disposeMaterials(babylonMaterialsToDispose);
  }
  _disposeMaterials(babylonMaterials) {
    const babylonTextures = {};
    for (const babylonMaterial of babylonMaterials) {
      for (const babylonTexture of babylonMaterial.getActiveTextures()) {
        babylonTextures[babylonTexture.uniqueId] = babylonTexture;
      }
      babylonMaterial.dispose();
    }
    for (const uniqueId in babylonTextures) {
      for (const babylonMaterial of this._loader.babylonScene.materials) {
        if (babylonMaterial.hasTexture(babylonTextures[uniqueId])) {
          delete babylonTextures[uniqueId];
        }
      }
    }
    for (const uniqueId in babylonTextures) {
      babylonTextures[uniqueId].dispose();
    }
  }
};
GLTFLoader2.RegisterExtension(NAME25, (loader) => new MSFT_lod(loader));

// node_modules/@babylonjs/loaders/glTF/2.0/Extensions/MSFT_minecraftMesh.js
var NAME26 = "MSFT_minecraftMesh";
var MSFT_minecraftMesh = class {
  constructor(loader) {
    this.name = NAME26;
    this._loader = loader;
    this.enabled = this._loader.isExtensionUsed(NAME26);
  }
  dispose() {
    this._loader = null;
  }
  loadMaterialPropertiesAsync(context, material, babylonMaterial) {
    return GLTFLoader2.LoadExtraAsync(context, material, this.name, (extraContext, extra) => {
      if (extra) {
        if (!(babylonMaterial instanceof PBRMaterial)) {
          throw new Error(`${extraContext}: Material type not supported`);
        }
        const promise = this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial);
        if (babylonMaterial.needAlphaBlending()) {
          babylonMaterial.forceDepthWrite = true;
          babylonMaterial.separateCullingPass = true;
        }
        babylonMaterial.backFaceCulling = babylonMaterial.forceDepthWrite;
        babylonMaterial.twoSidedLighting = true;
        return promise;
      }
      return null;
    });
  }
};
GLTFLoader2.RegisterExtension(NAME26, (loader) => new MSFT_minecraftMesh(loader));

// node_modules/@babylonjs/loaders/glTF/2.0/Extensions/MSFT_sRGBFactors.js
var NAME27 = "MSFT_sRGBFactors";
var MSFT_sRGBFactors = class {
  constructor(loader) {
    this.name = NAME27;
    this._loader = loader;
    this.enabled = this._loader.isExtensionUsed(NAME27);
  }
  dispose() {
    this._loader = null;
  }
  loadMaterialPropertiesAsync(context, material, babylonMaterial) {
    return GLTFLoader2.LoadExtraAsync(context, material, this.name, (extraContext, extra) => {
      if (extra) {
        if (!(babylonMaterial instanceof PBRMaterial)) {
          throw new Error(`${extraContext}: Material type not supported`);
        }
        const promise = this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial);
        if (!babylonMaterial.albedoTexture) {
          babylonMaterial.albedoColor.toLinearSpaceToRef(babylonMaterial.albedoColor);
        }
        if (!babylonMaterial.reflectivityTexture) {
          babylonMaterial.reflectivityColor.toLinearSpaceToRef(babylonMaterial.reflectivityColor);
        }
        return promise;
      }
      return null;
    });
  }
};
GLTFLoader2.RegisterExtension(NAME27, (loader) => new MSFT_sRGBFactors(loader));

// node_modules/@babylonjs/loaders/glTF/2.0/Extensions/ExtrasAsMetadata.js
var NAME28 = "ExtrasAsMetadata";
var ExtrasAsMetadata = class {
  constructor(loader) {
    this.name = NAME28;
    this.enabled = true;
    this._loader = loader;
  }
  _assignExtras(babylonObject, gltfProp) {
    if (gltfProp.extras && Object.keys(gltfProp.extras).length > 0) {
      const metadata = babylonObject.metadata = babylonObject.metadata || {};
      const gltf = metadata.gltf = metadata.gltf || {};
      gltf.extras = gltfProp.extras;
    }
  }
  dispose() {
    this._loader = null;
  }
  loadNodeAsync(context, node, assign) {
    return this._loader.loadNodeAsync(context, node, (babylonTransformNode) => {
      this._assignExtras(babylonTransformNode, node);
      assign(babylonTransformNode);
    });
  }
  loadCameraAsync(context, camera, assign) {
    return this._loader.loadCameraAsync(context, camera, (babylonCamera) => {
      this._assignExtras(babylonCamera, camera);
      assign(babylonCamera);
    });
  }
  createMaterial(context, material, babylonDrawMode) {
    const babylonMaterial = this._loader.createMaterial(context, material, babylonDrawMode);
    this._assignExtras(babylonMaterial, material);
    return babylonMaterial;
  }
};
GLTFLoader2.RegisterExtension(NAME28, (loader) => new ExtrasAsMetadata(loader));
export {
  __exports as GLTF1,
  __exports2 as GLTF2,
  GLTFFileLoader,
  GLTFLoaderAnimationStartMode,
  GLTFLoaderCoordinateSystemMode,
  GLTFLoaderState,
  GLTFValidation
};
//# sourceMappingURL=@babylonjs_loaders_glTF.js.map
